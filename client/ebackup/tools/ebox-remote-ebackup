#!/usr/bin/perl
# Copyright (C) 2009-2010 eBox Technologies S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Script: ebox-remote-ebackup
#
# This script is called from crontab to carry out a full or incremental
# backup depending on the user configuration
#
# It takes one argument that can be:
#
#   --full (default)
#   --incremental


use strict;
use warnings;

use EBox;
use EBox::Config;
use EBox::Global;
use EBox::Gettext;
use EBox::Sudo;
use EBox::Event;

use Error qw(:try);

sub _sendEvent
{
    my ($msg, $level) = @_;

    # Generate event
    my $global = EBox::Global->getInstance(1);
    if ($global->modExists('events')) {
        my $events = $global->modInstance('events');
        if ((defined $events)  and ($events->isRunning())) {
            my $enabled = $events
                ->isEnabledWatcher('EBox::Event::Watcher::EBackup')->value();
            if ($enabled) {
                $events->sendEvent(message => $msg,
                        source  => 'EBackup',
                        level   => $level);
            }
        }
    }
}


sub _sendSuccessEvent
{
    my ($success, $msgError) = @_;
    my $msg;
    my $level;
    if ($success) {
        $msg = __('Zentyal backup succeeded');
        $level = 'info';
    } else {
        if ($msgError) {
            $msg = __x("Zentyal backup failed: {error}",
                   error => $msgError);
        } else {
            $msg = __("Zentyal backup failed"),
        }

        $level = 'error';
    }

    _sendEvent( $msg, $level);
}


sub _mangleErrorMsg
{
    my ($msg) = @_;

    my $spaceLeftRe =  qr/^Temp space has (\d+) available, backup needs approx (\d+)/;

    if ($msg =~ m/$spaceLeftRe/) {
        my ($avail, $need) = ($1, $2);
        $avail = _bytesToMB($avail);
        $need = _bytesToMB($need);
        my $tmpDir = '/tmp';

        return __x(
                   q{Temp directory '{dir}' has {avail} MB available, backup needs approx {need} MB. Either free some space or change volume size settings in /etc/ebox/82ebackup.conf.},
                   dir   => $tmpDir,
                   avail => $avail,
                   need => $need,
                  );
    }

    return $msg;
}

sub _bytesToMB
{
    my ($bytes) = @_;
    return sprintf('%.3f', $bytes/1048576);
}

sub _existsFullBackup
{
    my ($ebackup) = @_;

    my $status = $ebackup->remoteStatus();
    foreach my $st (@{ $status }) {
        if ($st->{type} eq 'Full') {
            return 1;
        }
    }

    return 0;
}


sub usage
{
    print __('Usage:');
    print "\n";
    print "$0 [--full|--incremental]";
    print "\n";
}


sub _adjustType
{
    my ($ebackup, $type) = @_;

# We need an updated cache to avoid errors while checking the status if backup
# files have been re/moved
#
# We can disable this feature to speed up process when there is not full backup,
# incremetal is specified and status cache is not properly updated it will give a
# "old sigantures not found" error
    $ebackup->remoteGenerateStatusCache();

    if ($type eq 'full-only-once') {
        if (_existsFullBackup($ebackup)) {
            $type = 'incremental';
        } else {
            EBox::info('No full backup detected in archive. We will make a full backup, following backups will be incremental');
            $type = 'full';
        }
    } elsif ($type eq 'incremental') {
        if (not _existsFullBackup($ebackup)) {
            EBox::warn('Incremental backup requested but there are not full backups. Switching to full backup mode');
            $type = 'full';
        }
    }

    return $type;
}


sub _checkAllModulesUnchanged
{
    my ($self) = @_;

    my @changed;
    my $global = EBox::Global->getInstance();
    foreach my $modName (@{ $global->modNames() }) {
        if ($global->modIsChanged($modName)) {
            push @changed, $modName;
        }
    }

    if (@changed) {
        my $mods = join ',', @changed;
        my $msg = __x('Cannot backup because the following modules have unsaved changes: {mods}',
                     mods => $mods);
        _sendSuccessEvent(0,  $msg);
        print "$msg\n";
        exit 0;
    }

}

sub _removeExpiredBackups
{
    my ($ebackup) = @_;
    my $removeArguments = $ebackup->remoteDelOldArguments();
    EBox::Sudo::root($removeArguments);
}


my $type = 'full';

if ($ARGV[0]) {
    if ($ARGV[0] eq '--incremental') {
        $type = 'incremental';
    } elsif ($ARGV[0] eq '--full') {
        $type = 'full';
    } else {
        print "Invalid argument: " . $ARGV[0];
        print "\n";
        usage();
        exit 1;
    }
}


EBox::init();

my $globalRO = 1;
my $ebackup = EBox::Global->getInstance($globalRO)->modInstance('ebackup');
unless ($ebackup->isEnabled() ) {
    print "Backup module is disabled\n";
    exit 0;
}
unless ($ebackup->configurationIsComplete()) {
    print "Backup module configuration is not completed. Configure it and retry\n";
    exit 0;

}

_checkAllModulesUnchanged();

my $mustExit = 0;
try {
        $ebackup->backupProcessLock()
} otherwise {
    my $alreadyMsg = __('Another backup process is running, wait until it finish and try again');
    print $alreadyMsg;
    print "\n";
    _sendSuccessEvent(0,  $alreadyMsg);
    $mustExit= 1;
};
if ($mustExit) {
    exit $mustExit;
}

try {
   $ebackup->lock() ;
} otherwise {
    $ebackup->backupProcessUnlock();
    my $busyMsg = __('The backup module is busy, retry later');
    print $busyMsg;
    print "\n";
    _sendSuccessEvent(0,  $busyMsg);
    $mustExit =  1;
};

if ($mustExit) {
    exit $mustExit;
}

try {
    $type = _adjustType($ebackup, $type);

    if ($type eq 'full') {
        _removeExpiredBackups($ebackup);
    }

    try {
        $ebackup->dumpExtraData($globalRO);
    } otherwise {
        my $ex = @_;
        EBox::error("Error dumping server metadata: $ex. Backup process continue but you wont be able to restore the server configuration with this backup");
    };


    my $backupCmd = $ebackup->remoteArguments($type);
    my $errorMsg;
    my $success = 1;
    try {
        EBox::Sudo::root($backupCmd);
    } otherwise {
        my $ex = shift @_;
        my @error = @{  $ex->error() };
        chomp $error[-1];
        $errorMsg = "@error";
        $errorMsg = _mangleErrorMsg($errorMsg);

        print "Backup failed: $errorMsg\n";
        $success = 0;
    };

    _sendSuccessEvent($success, $errorMsg);
    EBox::info('Backup process finished');
} finally {
    # Create status
    $ebackup->remoteGenerateStatusCache();

    # Create file list
    $ebackup->remoteGenerateListFile();

    $ebackup->backupProcessUnlock();
    $ebackup->unlock();
};

exit 0;
