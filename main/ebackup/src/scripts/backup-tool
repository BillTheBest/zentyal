#!/usr/bin/perl
# Copyright (C) 2009-2010 eBox Technologies S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Script: backup-tool
#
# This script is called from crontab to carry out a full or incremental
# backup depending on the user configuration
#
# It takes one argument that can be:
#
#   --full (default)
#   --incremental
#   --full-only-once

use strict;
use warnings;

use feature "switch";

use EBox;
use EBox::Config;
use EBox::Exceptions::External;
use EBox::Global;
use EBox::Gettext;
use EBox::Sudo;
use EBox::Event;
use EBox::EBackup::Subscribed;

use Error qw(:try);

use constant EBACKUP_CONF => EBox::Config::etc() . 'ebackup.conf';

sub _sendEvent
{
    my ($msg, $level) = @_;

    # Generate event
    my $global = EBox::Global->getInstance(1);
    if ($global->modExists('events')) {
        my $events = $global->modInstance('events');
        if ((defined $events)  and ($events->isRunning())) {
            my $enabled = $events
                ->isEnabledWatcher('EBox::Event::Watcher::EBackup')->value();
            if ($enabled) {
                $events->sendEvent(message => $msg,
                        source  => 'EBackup',
                        level   => $level);
            }
        }
    }
}

sub _sendSuccessEvent
{
    my ($success, $type, $msgError) = @_;
    my $msg;
    my $level;

    my $printableMode;
    if ($type eq 'full') {
        $printableMode = __('full');
    } elsif ($type eq 'incremental') {
        $printableMode = __('incremental');
    } else {
        $printableMode = $type;
    }


    if ($success) {
        $msg = __x('Zentyal {mode} backup succeeded',
                    mode => $printableMode);
        $level = 'info';
    } else {
        if ($msgError) {
            $msg = __x("Zentyal {mode} backup failed: {error}",
                       mode  => $printableMode,
                       error => $msgError,
                      );
        } else {
            $msg = __x("Zentyal {mode} backup failed",
                       mode  => $printableMode,
                      );
        }

        $level = 'error';
    }
    _sendEvent( $msg, $level);
}

sub _mangleDuplicityErrorMsg
{
    my ($msg) = @_;

    my $spaceLeftRe = qr/^Temp space has (\d+) available, backup needs approx (\d+)/;
    my $backendException = qr/^BackendException:/;

    given ( $msg ) {
        when (m/$spaceLeftRe/) {
            my ($avail, $need) = ($1, $2);
            $avail = _bytesToMB($avail);
            $need = _bytesToMB($need);
            my $tmpDir = EBox::EBackup::tempdir();

            return __x(
                q/Temp directory '{dir}' has {avail} MB available, backup needs approx {need} MB. Either free some space or change temporal directory and volume size settings in {conf}./,
                dir   => $tmpDir,
                avail => $avail,
                need  => $need,
                conf  => EBACKUP_CONF,
               );
        }

        when ( m/$backendException/ ) {
            return 'BackendException';
        }

        default { return $msg; }
    }

}

sub _bytesToMB
{
    my ($bytes) = @_;
    return sprintf('%.3f', $bytes/1048576);
}

sub _existsFullBackup
{
    my ($ebackup) = @_;

    my $status = $ebackup->remoteStatus();
    foreach my $st (@{ $status }) {
        if ($st->{type} eq 'Full') {
            return 1;
        }
    }

    return 0;
}

sub usage
{
    print __('Usage:');
    print "\n";
    print "$0 [--full|--incremental|--full-only-once]";
    print "\n";
}

sub _adjustType
{
    my ($ebackup, $type) = @_;

# We need an updated cache to avoid errors while checking the status if backup
# files have been re/moved
#
# We can disable this feature to speed up process when there is not full backup,
# incremental is specified and status cache is not properly updated it will give a
# "old sigantures not found" error
    $ebackup->remoteGenerateStatusCache();

    if ($type eq 'full-only-once') {
        if (_existsFullBackup($ebackup)) {
            $type = 'incremental';
        } else {
            EBox::info('No full backup detected in archive. We will make a full backup, following backups will be incremental');
            $type = 'full';
        }
    } elsif ($type eq 'incremental') {
        if (not _existsFullBackup($ebackup)) {
            EBox::warn('Incremental backup requested but there are not full backups. Switching to full backup mode');
            $type = 'full';
        }
    }

    return $type;
}

# Return whether there are unsaved changes or not
sub _unsavedChangesWarning
{
    my ($type) = @_;

    my @changed;
    my $global = EBox::Global->getInstance(); # rw instance to get change status
    foreach my $modName (@{ $global->modNames() }) {
        if ($global->modIsChanged($modName)) {
            push @changed, $modName;
        }
    }

    if (@changed) {
        my $mods = join ',', @changed;
        my $msg = __x('Configuration backup skipped because the following modules have unsaved changes: {mods}. The rest of the backup will not be affected',
                      mods => $mods);
        _sendSuccessEvent(0, $type, $msg);
        print "$msg\n";
        return 1;
    }

    return 0;
}

sub _removeExpiredBackups
{
    my ($ebackup) = @_;

    try {
        my $removeArguments = $ebackup->remoteDelOldArguments();
        EBox::Sudo::root($removeArguments);
        # Delete orphaned metadata
        my $settingsModel = $ebackup->model('RemoteSettings');
        my $method = $settingsModel->row()->valueByName('method');
        if ($method eq 'cloud') {
            EBox::EBackup::Subscribed::deleteOrphanMetadata($ebackup->remoteStatus());
        }
    } catch EBox::Exceptions::Sudo::Command with {
        my $ex = shift @_;
        my $errorMsg = $ex->error()->[-1];
        chomp($errorMsg);
        $errorMsg = _mangleDuplicityErrorMsg($errorMsg);
        if ( $errorMsg eq 'BackendException' ) {
            $errorMsg = __('Cannot contact to the backup server. Check your '
                           . 'Internet connection prior to perform the backup');
        }
        throw EBox::Exceptions::External($errorMsg);
    };

}

sub _cleanup
{
    my ($ebackup) = @_;

    my $duplicityWrapper = $ebackup->DUPLICITY_WRAPPER();
    my $remoteUrl = $ebackup->_remoteUrl();
    my $cmd = "$duplicityWrapper cleanup --force $remoteUrl";
    EBox::debug('Trying to clean up incomplete backups');
    EBox::Sudo::root($cmd);
}

# Try to back up with n_tries using a geometric progression
# Returns two values in an array:
#      success  - Boolean indicating if it was a success
#      errorMsg - String if there wasn't success, the error message
#
sub _performBackup
{
    my ($backupCmd) = @_;

    my $ebackupConfKeys = EBox::Config::configKeysFromFile(EBACKUP_CONF);
    my $nTries   = $ebackupConfKeys->{n_tries};
    my $initial  = $ebackupConfKeys->{initial_value};
    my $factor   = $ebackupConfKeys->{scale_factor};

    my $success  = 1;
    my $errorMsg = "";

    foreach my $try ( 1 .. $nTries ) {
        try {
            EBox::info("Backing up files to destination: try $try");
            EBox::Sudo::root($backupCmd);
        } catch  EBox::Exceptions::Sudo::Command with {
            my $ex = shift @_;
            $success = 0;
            my @error = @{  $ex->error() };
            chomp $error[-1];
            $errorMsg = "@error";
            $errorMsg = _mangleDuplicityErrorMsg($errorMsg);
        } otherwise {
            my ($ex) = @_;
            $success = 0;
            $errorMsg = "$ex";
        };
        last if ($success);
        # Error comes from a timeout? We can only assure the exception
        # comes from the backend
        last unless ( $errorMsg eq 'BackendException' );
        if ( $try < $nTries ) {
            my $timeout = int($initial * $factor**($try - 1));
            EBox::warn("Cannot contact the server: sleeping for $timeout seconds");
            sleep($timeout);
        } else {
            # Set a beautiful message to send to the user
            $errorMsg = __('Cannot contact to the backup server. Check your '
                           . 'Internet connection prior to perform the backup');
        }
    }

    return ($success, $errorMsg);

}

my $type = 'full';
if ($ARGV[0]) {
    if ($ARGV[0] eq '--incremental') {
        $type = 'incremental';
    } elsif ($ARGV[0] eq '--full') {
        $type = 'full';
    } elsif ($ARGV[0] eq '--full-only-once') {
        $type = 'full-only-once';
    } else {
        print "Invalid argument: " . $ARGV[0];
        print "\n";
        usage();
        exit 1;
    }
}

EBox::init();

my $globalRO = 1;
my $ebackup = EBox::Global->getInstance($globalRO)->modInstance('ebackup');
unless ($ebackup->isEnabled() ) {
    print "Backup module is disabled\n";
    exit 0;
}
unless ($ebackup->configurationIsComplete()) {
    print "Backup module configuration is not completed. Configure it and retry\n";
    exit 0;

}

my $unsavedChanges = _unsavedChangesWarning($type);

my $mustExit = 0;

try {
    $ebackup->backupProcessLock()
} otherwise {
    my $alreadyMsg = __('Another backup process is running, wait until it finishes and try again');
    print $alreadyMsg;
    print "\n";
    _sendSuccessEvent(0, $type, $alreadyMsg);
    $mustExit= 1;
};
if ($mustExit) {
    exit $mustExit;
}


try {
   $ebackup->lock() ;
} otherwise {
    $ebackup->backupProcessUnlock();
    my $busyMsg = __('The backup module is busy, retry later');
    print $busyMsg;
    print "\n";
    _sendSuccessEvent(0, $type, $busyMsg);
    $mustExit =  1;
};



if ($mustExit) {
    exit $mustExit;
}


my $errorMsg;
my $success = 1;
my $configurationDumped = 0;
my $usingCloud = $ebackup->model('RemoteSettings')->row()->valueByName('method') eq 'cloud';
try {
    $type = _adjustType($ebackup, $type);

    if ($type eq 'full') {
        _removeExpiredBackups($ebackup);
    }

    try {
        $ebackup->dumpExtraData($globalRO);
        $configurationDumped = (not $unsavedChanges);
    } otherwise {
        my $ex = @_;
        EBox::error("Error dumping server metadata: $ex. Backup process continues but you won't be able to restore the server configuration with this backup");
    };


    my $backupCmd = $ebackup->remoteArguments($type);
    my ($success, $errorMsg) = _performBackup($backupCmd);

    if ( $success and $usingCloud) {
        $ebackup->remoteGenerateStatusCache();
        my $availableDomains = $ebackup->availableBackupDomains();
        my @enabledDomains = grep { $availableDomains->{$_}->{enabled} } keys %{$availableDomains};
        my %backupDomains = map
          { $_ => { description   => $availableDomains->{$_}->{description},
                    printableName => $availableDomains->{$_}->{printableName} } }
            @enabledDomains;
        EBox::info('Writing Disaster Recovery metadata');
        EBox::EBackup::Subscribed::writeDRMetadata(
            configurationDumped => $configurationDumped,
            date                => $ebackup->lastBackupDate(),
            backupType          => $type,
            backupDomains       => \%backupDomains,
           );
    }

    if ( $success ) {
        EBox::info('Backup process finished successfuly');
    } else {
        my $msg = "Backup failed: $errorMsg";
        print "$msg\n";
        EBox::error($msg);
        _cleanup($ebackup);
    }

    _sendSuccessEvent($success, $type, $errorMsg);

} finally {
    try {
        if ( $success ) {
            if (not $usingCloud) {
                $ebackup->remoteGenerateStatusCache();
            }

            # Create file list
            $ebackup->remoteGenerateListFile();
        }
    } finally {
        # This code must be run always
        $ebackup->backupProcessUnlock();
        $ebackup->unlock();
    }
};

# update logs, we do this even with a failed backup bz it could change disk
# usage, with leftover files..
$ebackup->gatherReportInfo();
my $cloudProf = EBox::Global->modInstance('cloud-prof');
if ($cloudProf) {
    $cloudProf->ebackupAlerts();
}

exit 0;
