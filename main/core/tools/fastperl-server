#!/usr/bin/perl
# Copyright (C) 2011 eBox Technologies S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use warnings;
use strict;

use IO::Socket::UNIX;
use POSIX qw(:sys_wait_h);
use Socket::PassAccessRights;
use File::Slurp;
use JSON::XS;

my $SOCKET_FILE = '/tmp/singleperl.sock';

#TODO: my $FORK_MODE = ! -f EBox::Global->DPKG_RUNNING_FILE; ?
my $FORK_MODE = 1;

$ENV{SINGLE_INTERP} = 1;

if ($FORK_MODE) {
# TODO: preload stuff
}

if ($FORK_MODE) {
    $SIG{CHLD} = 'IGNORE';
}

unlink ($SOCKET_FILE);

# TODO: Handle SIGPIPE?

my $umask = umask(077);
my $sock = new IO::Socket::UNIX(Local => $SOCKET_FILE,
                                Type => SOCK_STREAM,
                                Listen => SOMAXCONN,
                                Reuse => 1) or die "Cannot create socket: $!";
umask($umask);

while (1) {
    while (my $new_sock = $sock->accept()) {
        if ($FORK_MODE) {
            my $child;
            if ($child = fork()) {
                close $new_sock;
            } elsif (defined $child) {
                $SIG{CHLD} = 'DEFAULT';
                close $sock;
                handle($new_sock);
                exit;
            } else {
                # TODO: log this
                die "$0 ($$): fork: $!";
            }
        } else {
            handle($new_sock);
            close $new_sock;
        }
    }
}

sub handle
{
    my ($sock) = @_;

    # TODO: Handle this better
    my $outfd = Socket::PassAccessRights::recvfd(fileno($sock)) or
        die "recvfd STDOUT failed";
    my $errfd = Socket::PassAccessRights::recvfd(fileno($sock)) or
        die "recvfd STDERR failed";

    my $buf = <$sock>;
    if (defined $buf) {
        chomp $buf;
        my ($cmd, $rest) = $buf =~ /^([^:]+):(.*)/;
        my @args = @{decode_json($rest)};
        #DEBUG: print "$0 ($$): request to execute: $cmd @args\n";

        $buf = <$sock>;
        if (defined $buf) {
            my $env = decode_json($buf);

            redirect($outfd, $errfd);

            my $exitValue = execute($env, $cmd, @args);
            #DEBUG: print "$0 ($$): sending result: $exitValue\n";
            print $sock "$exitValue\n";

            endredirect();
        }
    }
}

sub execute
{
    my ($env, $file, @args) = @_;

    my $code = read_file($file);
    {
        local $SIG{PIPE} = sub {
            #DEBUG: print STDERR "SIGPIPE received\n";
        };
        local $SIG{__WARN__} = sub {
            #DEBUG: print STDERR "WARNING: @_\n";
        };

        # Save current environment and commandline
        my %oldEnv = %ENV;
        my ($oldProg, @oldArgs) = ($0, @ARGV);

        # Set environment and commandline for the hosted script
        %ENV = %{$env}; $ENV{SINGLE_INTERP} = 1;
        ($0, @ARGV) = ($file, @args);

        my $exitValue;
        eval 'BEGIN { *CORE::GLOBAL::exit = sub { die "ret=@_"; } };' . $code;
        if ($@) {
            ($exitValue) = $@ =~ /^ret=(\d+)/;
            unless (defined $exitValue) {
                #DEBUG: print STDERR "ERROR: $@\n";
                $exitValue = 1;
            }
        } else {
            $exitValue = 0;
        }

        # Restore saved values
        %ENV = %oldEnv;
        ($0, @ARGV) = ($oldProg, @oldArgs);

        #DEBUG: print "RETURN VALUE: $exitValue\n";
        return $exitValue;
    };
}

my ($oldout, $olderr, $out, $err);

sub redirect
{
    my ($outfd, $errfd) = @_;

    open ($oldout, '>&STDOUT');
    close (STDOUT);
    open ($out, ">&=$outfd");
    STDOUT->fdopen($out, 'w');
    STDOUT->autoflush(1);

    open ($olderr, '>&STDERR');
    close (STDERR);
    open ($err, ">&=$errfd");
    STDERR->fdopen($err, 'w');
    STDERR->autoflush(1);
}

sub endredirect
{
    close ($out);
    close (STDOUT);
    open (STDOUT, '>&', $oldout);

    close ($err);
    close (STDERR);
    open (STDERR, '>&', $olderr);
}

