#!/usr/bin/perl
# Copyright (C) 2010-2011 eBox Technologies S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use warnings;

use EBox;
use EBox::Backup;
use EBox::Config;
use EBox::EBackup::DBRestore;
use EBox::EBackup::Password;
use EBox::EBackup::Subscribed;
use EBox::Gettext;
use EBox::Global;
use EBox::NetWrappers;
use EBox::RemoteServices::ProxyBackup;
use EBox::ServiceManager;
use EBox::Sudo;
use EBox::Exceptions::Command;
use EBox::Exceptions::EBackup::FileNotFoundInBackup;
use EBox::Exceptions::EBackup::BadSymmetricKey;
use Error qw(:try);
use Getopt::Long;
use POSIX 'setsid';
use Term::ReadKey;
use Date::Parse;
use DateTime;
use String::ShellQuote;
use YAML::XS;
use File::Basename;

use constant NTP_SERVER     => 'pool.ntp.org';
use constant CHANGE_HOSTNAME_SCRIPT => '/usr/share/zentyal/change-hostname';

my $usesX = 1; # flag to signal whether graphical environment is available

my $xauthCookie;
my $usage = 0;
my ($user, $password, $serverCN);
my $restoreLast = 0;
my @toRestoreCli = ();
my $restoreAllDomains;
my $noEncryption;
my $symmetricPassword = undef;
my $encryptKey = undef;
my $keyPassphrase;
my %forceCredentials = (username => undef, password => undef, server => undef, noCloudLogin => undef   );
my $error = 0;
my %filesMD5;
my @pendingMessages;

parseArgs();

$xauthCookie = _xauthCookie();

EBox::init();

if ($usesX) {
    zenityPrecondition();
}

_xauthEBox($xauthCookie);

my $metadata;
try {
    EBox::info("Starting restore-tool");
    clearTmpDir();
    createTmpDir();
    modPreConditions();
    setSystemDate();
    # Stop any interrupting process
    _stopInterruptingProcesses();

    my $basicInfo = getUserAndPasswordAndServers($user, $password, \%forceCredentials);
    my $credentials;
    my $date;

    while (not $date) {
        $credentials = getCredentials($basicInfo->{user},
                                      $basicInfo->{password},
                                      $basicInfo->{servers},
                                      $serverCN,
                                      \%forceCredentials
                                     );

        unless ( $credentials->{type} eq 'basic' ) {
            getEncryption(
                $credentials,
                undef,
                symmetricPassword => $symmetricPassword,
                encryptionKey     => $encryptKey,
                keyPassphrase     => $keyPassphrase,
                noEncryption      => $noEncryption,
               );
        }

        # Restore last backup for basic users always
        $restoreLast = ($restoreLast or ($credentials->{type} eq 'basic'));

        $date = askBackupDate($credentials, $restoreLast);

        if (not $date) {
            my $msg = __('No backups found in this server. Do you want to retry with a different one?');
            my $retry = $usesX ? _zenityQuestion($msg) : terminalQuestion($msg);
            if (not $retry) {
                exit 0;
            }
            next; # start again, retry
        }

        unless ( $credentials->{type} eq 'basic' ) {
            my $metadataPath = _downloadBackupMetadata($credentials, $date);
            $metadata = readMetadataFile($metadataPath);

            unless ( $metadata->{hasConfiguration} ) {
                my $msg = __('There is not configuration backup from this date. '
                             . 'Do you want to retry with another date?');
                my $retry = $usesX ? _zenityQuestion($msg) : terminalQuestion($msg);
                if (not $retry) {
                    exit(0);
                }
                undef($date);
                next; # Start all over again, retry
            }
        }
    }

    my $toRestore = getBackupDomainsToRestore($credentials,
                                              $metadata,
                                              $restoreAllDomains,
                                              \@toRestoreCli);
    _logStartProcess($credentials, $date, $toRestore);

    my $configBackup = _getConfigBackup($credentials, $metadata, $date);

    _installMissingModules($configBackup);

    takeFilesMD5();

    doRestore(credentials => $credentials,
              toRestore   => $toRestore,
              configBackup => $configBackup,
              date         => $date,
              metadata     => $metadata,
             );

    saveChanges();

    regenerateCaches();

    finishedMessages($credentials, $metadata);
    clearTmpDir(); # Comment this for debug purposes
} otherwise {
    my $ex = shift @_;
    fatal($ex);
    $error = 1;
} finally {
    EBox::Global->deleteFirst();
};

exit $error;

sub parseArgs
{
    my $correct = GetOptions(
            'usage|help' => \$usage,
            'user|username=s' => \$user,
            'password=s' => \$password,
            'server-cn=s'   => \$serverCN,
            'backup-domain=s' => \@toRestoreCli,
            'restore-all-domains' => \$restoreAllDomains,
            'x|gui!' => \$usesX,
            'last-date!' => \$restoreLast,
            'symmetric-password=s' => \$symmetricPassword,
            # TODO: Uncomment to enable gpg decrypt
            #'encryption-key=s'  => \$encryptKey,
            #'key-passphrase=s'   => \$keyPassphrase,
            'no-encryption+'     => \$noEncryption,
            'force-username=s'  => \$forceCredentials{username},
            'force-password=s'  => \$forceCredentials{password},
            'force-server=s'  => \$forceCredentials{server},
            'force-no-cloud-login' => \$forceCredentials{noCloudLogin},
            'force-type=s'           => \$forceCredentials{type},
            );

    if ($usage or (not $correct)) {
        usage();
    }

    my $cryptOptions = grep { $_ } ($encryptKey, $symmetricPassword, $noEncryption);
    if ($cryptOptions > 1) {
        die __x('You can only specify one of the encryption options: {sy}, {no}',
                sy  => '--symmetric-password',
                no  => '--no-encryption');
    }

    if (defined $forceCredentials{type}) {
        my $type = $forceCredentials{type};
        if (($type ne 'basic') and ($type ne 'subscribed')) {
            die __(q{--force-type should have as argument either 'basic' or 'subscribed'});
        }
    }

    if ($noEncryption) {
        $symmetricPassword = 0;
        $encryptKey = 0;
        $keyPassphrase = 0;
    }
}

sub zenityPrecondition
{
    system 'which zenity 1> /dev/null';
    if ($? != 0) {
        print __('Zenity package not found. Falling back to terminal mode') . "\n";
        $usesX = 0;
    }
}

sub usage
{
    print "restore-tool  [--user=username] [--password=password] [--server=serverCommonName] [--last-date] [--restore-all]\n";
    print "              [--backup-domain=domain1] [--backup-domain=domain2]  ... \n";
    print "              [--no-encryption|--symmetric-password=PASSWORD]\n";
    print "              [--no-x]\n";
    print "              [--force-username=username] [--force-password=password] [--force-server=server] [--force-type=basic|subscribed] [--force-no-cloud-login]\n";
    print "\n";
    print "\t --user=USERNAME        \t ";
    print __("User for the authentication") . "\n";
    print "\t --password=PASSWORD    \t ";
    print __('Password for the authentication. This password will be shown both '
             . 'in the command line and in the process list so only use this option '
             . 'when security is not a concern') . "\n";
    print "\t --server=SERVER        \t ";
    print __("Server from which its backup date the restore will be done") . "\n";
    print "\t --last-date            \t ";
    print __("Use the last backup done for the restore")  . "\n";
    print "\t --restore-all            \t ";
    print __("Restore all backup domains available")  . "\n";
    print "\t --backup-domain=DOMAIN \t ";
    print __("Backup domain to restore. It could be repeated several times") . "\n";
    print "\t--no-encryption|--symmetric-password=PASSWORD\n";
    print __('Check if we use the no encryption or a symmetric encryption with password '), "\n";
    print "\t --no-x                 \t ";
    print __("Do not use graphical interface") . "\n";
    print "\t --force-username       \n"; 
    print "\t --force-password       \n"; 
    print "\t --force-server         \n "; 
    print "\t --force-no-cloud-login \n "; 
    print "\t --force-type           \t "; 
    print __("Change parameters used to access the storage server") . "\n";

    exit 0;
}

sub tmpDir
{
    return '/var/lib/zentyal/tmp/zentyal-restore';
}

sub filesTmpDir
{
    return tmpDir() . '/files';
}

sub metaTmpDir
{
    return tmpDir() . '/meta';
}

sub modPreConditions
{
    my @mods = ('ebackup', 'remoteservices'); # add software when used
    foreach my $modName (@mods) {
        unless (EBox::Global->modExists($modName)) {
            fatal(__x('Module {mod} should be installed', mod => $modName));
        }

        my $mod = EBox::Global->modInstance($modName);
        if ($mod->isa('EBox::Module::Service')) {
            unless ($mod->configured()) {
                fatal(__x('Module {mod} should be configured', mod => $modName));
            }
        }
    }
}

sub setSystemDate
{
    my $cmd = 'ntpdate ' . NTP_SERVER;
    try {
        EBox::Sudo::root($cmd);
    } otherwise {
        warning(__('Could not automatically update system date and hour. If the system time is not correct, some restore operations could fail'));
    };
}

sub askServerCN
{
    my ($servers) = @_;
    my $serverCN;
    if ($usesX) {
        my @serversOrdered = sort @{ $servers  };
        $serverCN = _zenityList(__('Choose the server to restore'),
                                __('Server'),
                                  0, \@serversOrdered);
    } else {
        showServerList($servers);
        $serverCN = terminalPrompt(__("Server to restore: "));
    }

    _checkServerCN($serverCN, $servers);

    return $serverCN;
}

sub askDomainsToRestore
{
    my ($credentials, $metadata) = @_;

    my %availableDomains = %{ _backupDomainsAvailableByPrintableName($metadata) };

    my @domains;
    if ($usesX) {
        my @elements;
        while (my ($printableName, $name) = each %availableDomains) {
            if ($name eq 'filesIncludes') {
                push @elements, {
                                 item => $printableName,
                                 enabled => 0,
                                }
            } else {
                push @elements, $printableName;
            }
        }

        my $answer = _zenityList(__('Select backup domains to restore'),
                                 __('Backup domain'),
                                 1,
                                 \@elements,
                                 enabledByDefault => 1,
                                );
        @domains = @{ $answer };
    } else {
        my @availablePrintableNames = keys %availableDomains;
        my $printableList = join ', ', @availablePrintableNames;
        print __x('Backup domains available in the server {cn}: {l}',
                  cn => $credentials->{commonName},
                  l => $printableList);
        print "\n";
        my $unparsed = terminalPrompt("Backup domains to restore (comma separated): ");
        @domains =  split ',', $unparsed;
        foreach  (@domains) {
            $_ =~ s/^\s+//;
            $_ =~ s/\s+$//;
        }
    }

    # get domain name form printable name
    @domains = map {
        exists $availableDomains{$_} ? $availableDomains{$_} : ()
    } @domains;

    if (not @domains) {
        fatal(__('No backup domain selected to restore. Doing nothing'));
    }

    my %toRestore = map { $_ => 1 } @domains;

    return \%toRestore;
}

sub serverList
{
    my ($remoteServices, $user, $password)  = @_;

    my $msg = __('Retrieving registered servers list');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    my $list;
    try {
        $list = $remoteServices->serverList(user => $user,
                                            password => $password);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    return $list;
}


sub _setupPasswords
{
    my ($credentials) = @_;

    my $encKey = '';
    my $symPasswd = '';
    if (exists $credentials->{encValue} and
         ($credentials->{encValue} ne 'disabled')) {
        if (exists $credentials->{encSelected}) {
            my $selected = $credentials->{encSelected};
            my $value    = $credentials->{encValue};
            if ($selected eq 'asymmetric') {
                $encKey = $value;
            } elsif ($selected eq 'symmetric') {
                $symPasswd = $value;
            }
        }
    }

    if ($symPasswd) {
        EBox::EBackup::Password::setSymmetricPassword($symPasswd, 1);
    }

    if ($encKey) {
        if (not $credentials->{keyPassphrase}) {
            fatal(__('No key passphrase'));
        }
        EBox::EBackup::Password::setGpgPassphrase($credentials->{keyPassphrase}, 1);
    }

    my $password = $credentials->{password};
    if (not defined $password) {
        fatal(__('No password in retrieved credentials'));
    }
    EBox::EBackup::Password::setPasswdFile($password, 1);
}


sub backupCredentials
{
    my %params = @_;
    my $remoteServices = delete $params{remoteServices};
    my $force          = delete $params{force};
    my $credentials;

    unless ($force->{noCloudLogin}) {
        $credentials = _credentialsFromCloud($remoteServices, %params);
    } else {
        $credentials = {};
    }

    if (not defined $credentials) {
        $credentials = {
            username => $params{username},
            password => $params{password},
            method   => 'scp',
            type     => 'basic',
        };
    } else {
        $credentials->{type} = 'subscribed';
    }

    foreach my $cred (qw(username password server type)) {
        if ($force->{$cred}) {
            $credentials->{$cred} = $force->{$cred};
        }
    }

    $credentials->{commonName} = $params{serverCN};

    $credentials->{confBackupDir} = EBox::EBackup::Subscribed::confBackupDir($credentials->{commonName});

    if (not exists $credentials->{method}) {
        $credentials->{method} = 'scp';
    }

    return $credentials;
}

sub _credentialsFromCloud
{
    my ($remoteServices, %params) = @_;

    my $credentials;
    my $msg = __('Retrieving account information');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        $credentials =
            $remoteServices->backupCredentials(
                    username   => $params{username},
                    password   => $params{password},
                    commonName => $params{serverCN},
                    force      => 1,
                    );
    } catch EBox::Exceptions::DataNotFound with  {
        $credentials = undef;
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    return $credentials;
}

sub addEncryptionToCredentials
{
    my ($credentials, %params) = @_;

    if ($credentials->{type} ne 'subscribed') {
        return $credentials;
    }

    if ($params{symmetricPassword}) {
        $credentials->{encSelected} = 'symmetric';
        $credentials->{encValue} = $params{symmetricPassword};
    } elsif ($params{encryptionKey}) {
        $credentials->{encSelected} = 'asymmetric';
        $credentials->{encValue} = $params{encryptionKey};
        $credentials->{keyPassphrase} = $params{keyPassphrase};
    } else {
        $credentials->{encSelected} = 'none';
        $credentials->{encValue} = 'disabled';
    }

    return $credentials;
}


sub showServerList
{
    my ($serverList) = @_;

    if (not @{ $serverList }) {
        fatal(__("No registered Zentyal Servers"));
    }

    my @ordered = sort @{ $serverList};

    print "\n";
    print __('Registered Zentyal Servers');
    print "\n--------------------------------------\n";
    foreach my $server (@ordered) {
        print $server, "\n";
    }

    print "\n";
}

sub doRestore
{
    my %params = @_;

    my $configBackup = $params{configBackup};
    my $credentials  = $params{credentials};
    my $date         = $params{date};
    my $metadata     = $params{metadata};
    my %toRestore    = %{ $params{toRestore} };

    # set hostname before restorign anything
    setHostname($metadata);

    my $restoreConfig = delete $toRestore{configuration};
    if ($restoreConfig) {
        restoreConfig($configBackup);

        if ( $credentials->{type} ne 'basic' ) {
            _installCloudPackages($configBackup); # install cloud packages need
                                                  # access to special repositories
                                                  # granted by remoteservices
        }
    }

    if ($credentials->{type} eq 'basic') {
        # basic subscriptions backups only store the configuration, so we have
        # finished
        return;
    }

    if (keys %toRestore == 0) {
        # only requested configuration restore, finished
        return;
    }

    _downloadBackupData($credentials, $date, \%toRestore, $metadata);

    my $ebackup = EBox::Global->modInstance('ebackup');

    my $urlParams   = _remoteUrlParamsFromCredentials($credentials, 'data');
    if ($toRestore{filesIncludes}) {
        _restoreAllFiles($ebackup, $date);
    } else {
        _restoreBackupDomainsFiles($ebackup, $date, \%toRestore);
    }


    if ($toRestore{logs}) {
        _restoreLogs($date);
    }
}


# Restore the files whose source are backup domains
sub _restoreBackupDomainsFiles
{
    my ($ebackup, $date, $toRestore) = @_;

    my $msg = __('Restoring files');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        # restore backup domains

        foreach my $mod (@{ EBox::Global->modInstances() }) {
            $mod->can('backupDomainsFileSelection') or next;

            my $selection = $mod->backupDomainsFileSelection(%{ $toRestore } );
            if ((not defined $selection) or (keys %{ $selection} == 0)) {
                next;
            }

            foreach my $file (@{ $selection->{'includes'} }) {
                $file =~ s{/+$}{};
                my $srcFile = _fileFromBackup($file);
                my $dstFile = $file;

                try {
                    _restoreFile($srcFile, $dstFile);
                } otherwise {
                    my $ex = shift;
                    my $msg = __x('Cannot restore file {file} requested by backup domains. Reason: {reason}',
                                  file => $file,
                                  reason => "$ex",
                                 );
                    EBox::warn($msg);
                };
            }
        }
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _restoreAllFiles
{
    my ($ebackup, $date) = @_;
    my $srcDir = filesTmpDir();

   # files and dirs that shouldnt be restored
    my @notRestoreFiles = (
        $0, # this  file itself

        '/boot',
        '/proc',
        '/dev',
        '/sys',
        '/lib',
        '/media',
        '/mnt',
        '/cdrom',
        '/floppy',
        # perl and zentyal modules
        '/usr/bin/perl',
        '/usr/share/perl*',
        '/usr/share/zentyal*',
        # zentyal home
        EBox::Config::home(),
        # zentyal /etc (restored in configuration restore)
        EBox::Config::etc(),
        # zenity
        '/usr/bin/zenity',
        # lib directory
        '/usr/lib',
        # sudo zentyal file
        '/etc/sudoers.d/ebox',
        # extra backup data dir is of no use
        $ebackup->extraDataDir(),
    );

    # no wildcards will be expanded in @renameFiles
    my @renameFiles = (
        '/var/log',
    );

    my $msg = __('Restoring all backed-up files');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    # regular files in / are not restored anyway they should be links to
    # /boot that should not be touched
    try {
        foreach my $file (@notRestoreFiles) {
            $file = $srcDir . '/' . $file;
            EBox::Sudo::silentRoot("ls $file");
            if ($? == 0) {
                EBox::info("This file(s) is in the backup but either  is not safe to automatically restore or is superfluous, skipping it: $file");
                EBox::Sudo::root("rm -rf $file");
            }
        }

        foreach my $file (@renameFiles) {
            $file = $srcDir . '/' . $file;
            EBox::Sudo::silentRoot("ls '$file'");
            if ($? == 0) {
                my $newName = $file . '.from-backup';
                EBox::info("The file $file will be restored as $newName");
                try {
                    EBox::Sudo::root("mv -b '$file' '$newName'");
                } otherwise {
                 EBox::error("The file $file cannot be restored as $newName. We will skip it");
                 EBox::Sudo::root("rm -rf $file");
             };
            }
        }

        my @dirsInBackup = @{ EBox::Sudo::root("find $srcDir -type d -maxdepth 1") };
        foreach my $dir (@dirsInBackup) {
            chomp $dir;
            my $toRestore = $dir;
            if ($toRestore eq $srcDir) {
                next;
            }

            $toRestore =~ s{^/*$srcDir}{};
            _restoreFile($dir, $toRestore);
        }
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _restoreFile
{
    my ($src, $dst) = @_;

    EBox::debug("About to try to restore $dst from $src");
    if (not EBox::Sudo::fileTest('-e', $src)) {
        EBox::error("Cannot restore $dst. Source path $src does not exists");
        return;
    }

    my $srcArg = $src;
    if (EBox::Sudo::fileTest('-e', $dst)) {
        if (EBox::Sudo::fileTest('-d' , $dst)) {
            if (not EBox::Sudo::fileTest('-d', $src)) {
                error(__x('Could not restore {dst}, it already exists and it is not a directory',
                          dst => $dst),
                      noBlocking => 1,
                     );
                return;
            }

            $srcArg = "$src/*";
            my $srcEmpty;
            try {
                EBox::Sudo::root("ls $srcArg");
            } otherwise {
                $srcEmpty = 1;
            };
            if ($srcEmpty) {
                # no files to copy to already existent directory..
                EBox::debug("No files to restore $dst; $src is empty");
                return;
            }
        }
    }

    my $dstDir = File::Basename::dirname($dst);
    if ($dstDir ne '/') {
       my $dstDirExists = EBox::Sudo::fileTest('-e', $dstDir);
       if (not $dstDirExists) {
           my $srcDir = File::Basename::dirname($src);
           _restoreDirTree($srcDir, $dstDir);
       }
    }

    my $restoreCmd = "cp -rpf $srcArg $dst";
    try {
        EBox::Sudo::root($restoreCmd);
    } otherwise {
        my $ex = shift;
        EBox::error("Restore file command failed $restoreCmd: $ex");
        error(__x(
                 'Error restoring file or directory {dst}. We will try to continue the restore',
                 dst => $dst,
                ),
              noBlocking => 1,
             );
    };
}

sub _restoreDirTree
{
     my ($src, $dst) = @_;
     my @dirs = ( [$src, $dst] );

     my $newDst = File::Basename::dirname($dst);
     my $newSrc = $src;
     while (($newDst ne '/') and not  EBox::Sudo::fileTest('-e', $newDst)) {
         my $newSrc = File::Basename::dirname($src);
         unshift @dirs, [$newSrc, $newDst];
         $newDst  = File::Basename::dirname($newSrc);
     }

     foreach  my $dirPair (@dirs) {
         my ($srcDir, $dstDir)  = @{ $dirPair };
         try {
             EBox::Sudo::root("mkdir $dstDir");
             EBox::Sudo::root("chmod --reference=$srcDir $dstDir");
             EBox::Sudo::root("chown --reference=$srcDir $dstDir");
         } catch EBox::Exceptions::Sudo::Command with {
             my $ex = shift;
             my $msg = __x('Error restoring directory {d}. This could make fail some files or domains restore processes. Error {e}',
                           d => $dstDir,
                           e => join '', @{ $ex->error }
                          );
             warning($msg, noBlocking => 1);
         };
     }
}

# sliced-mode is not supported
sub _restoreLogs
{
    my ($date) = @_;

    my $dir = EBox::EBackup::DBRestore::backupDir();
    my $dumpFile =  $dir . '/' . EBox::EBackup::DBRestore::dumpBasename() . '.dump';
    my $src = _fileFromBackup($dumpFile);


    if (not  EBox::Sudo::fileTest('-r', $src) ) {
        warning(__('Backup log data not found in the files from the backup, log database will not be restored'),
                noBlocking => 1
               );
        return;
    }

    _restoreFile($src, $dumpFile);

    my $msg = __('Restoring log database');
    my $pulsatePid = _showUnanticipatedProgress($msg);
    try {
        EBox::EBackup::DBRestore::restoreEBoxLogsFromDir($dir, $date);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub restoreConfig
{
    my ($configBackup) = @_;

    preRestoreConfigChecks($configBackup);

    my $progressIndicator =
        EBox::Backup->prepareRestoreBackup($configBackup,
                                           revokeAllOnModuleFail => 0,
                                           continueOnModuleFail  => 1
                                          );

    my $retValue = progress($progressIndicator, __('Restoring configuration backup'));
    if ($retValue != 0) {
        my $errorMsg = $progressIndicator->errorMsg();
        if ($errorMsg) {
            my $msg = $errorMsg . "\n";
            $msg .= __('The configuration restore failed. We will continue the process to try to restore as much as possible but your system will need manual tweaking');
            error($msg);
            return;
        } else {
            EBox::warn("Progress indicator for restoreConfig does not specify any error but has returned the following value: $retValue.");
        }
    }

    postRestoreConfigMangling();
}

sub preRestoreConfigChecks
{
    my ($configBackup) = @_;

    my $msg = __('Checking configuration compability');
    my $unanticipatedProgress = _showUnanticipatedProgress($msg);

    # check that interfaces referenced in network exist
    # XXX try to mangle this if possible to allow restore
    my $dir;
    try {
        $dir = EBox::Backup->_unpackAndVerify($configBackup);
        EBox::Backup->_unpackModulesRestoreData($dir);

        _preRestoreNetworkCheck($dir);
    } finally {
        system "rm -rf $dir";
        _finishUnanticipatedProgress($unanticipatedProgress);
    };
}


sub _preRestoreNetworkCheck
{
    my ($dir) = @_;

    my $confBakFile = "$dir/eboxbackup/network.bak/network.bak";
    if (not -r $confBakFile) {
        EBox::error("Cannot found data for network module, Skipping network pre-restore check");
        return;
    }

    my @enabledIfaces;

    # Open the config
    my @yaml = YAML::XS::LoadFile($confBakFile);
    foreach my $spec (@yaml) {
        my $iface;
        if ($spec->{key} =~ m{^/ebox/modules/network/interfaces/(.*?)/method$}) {
            $iface = $1;
        }  else {
            # not interested in this key
            next;
        }

        # no enabled, safe to ignore
        next if ($spec->{value} eq 'notset');

        push @enabledIfaces, $iface;
    }

    my @missing = grep {
        not EBox::NetWrappers::iface_exists($_)
    } @enabledIfaces;

    if (@missing) {
        my $msg = __x('Cannot restore backup because there are less interfaces than there are available. The missing interfaces are: {missing}',
                      missing => join ',', @missing
                     );
        fatal($msg);
    }
}

sub _installMissingModules
{
    my ($configBackup) = @_;

    my %modulesInBackup = map { $_ => 1 } @{ EBox::Backup->_modulesInBackup($configBackup) };
    my %modulesToConfigure  = %modulesInBackup;

    foreach my $modName ( @{ EBox::Global->modNames() }) {
        delete $modulesInBackup{$modName};
        my $mod = EBox::Global->modInstance($modName);
        if ((not $mod->isa('EBox::Module::Service')) or
             $mod->configured()) {
            delete $modulesToConfigure{$modName};
        }
    }

    my @missingModules = keys %modulesInBackup;
    if (@missingModules) {
        _updateDebPackagesList();
        EBox::info("Missing modules to recover the configuration: @missingModules");
        _installDebPackages(@missingModules);
    }

    my @unconfModules = keys %modulesToConfigure;
    if (@unconfModules) {
        EBox::info("Modules to configure: @unconfModules");
        _configureModules(@unconfModules);
    }
}


sub _updateDebPackagesList
{
    my ($msg) = @_;

    if (not $msg) {
        $msg = __('Updating software package lists');
    }

    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        EBox::Sudo::root('apt-get update -q');
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _installDebPackages
{
    my @modules = @_;

    my @packages;
    foreach my $mod (@modules) {
        next if EBox::Global->modExists($mod);

        # cloud-prof is a special case
        next if ($mod eq 'cloud-prof');

        push (@packages, "zentyal-$mod");
    }

    if (@packages) {
        my $msg = __('Installing Zentyal components and their dependencies');
        _aptInstall(\@packages, $msg);
    }

    # TODO: assure that modules are loaded and retrievable by EBox::Global->modInstance
}

sub _aptInstall
{
    my ($packages_r, $msg) = @_;

    my @packages = @{ $packages_r };

    my $software = EBox::Global->modInstance('software');
    my $progressIndicator = $software->installPkgs(@packages);
    my $retValue = progress($progressIndicator,
                         __('Installing missing modules...'));
    if ($retValue != 0) {
        my $errorMsg = $progressIndicator->errorMsg();
        my $msg;

        if ($errorMsg) {
            my $msg = __x('Error installing packages: {err}. The backup will continue but it would not able to recover any configuration  whcih depends on the missing packages',
                          err => "\n$errorMsg\n");
            error($msg, noBlocking => 1);
            return;
        } else {
            EBox::warn("Progress indicator for _aptInstall does not specify any error but has returned the following value: $retValue.");
        }
    }
}

sub _installCloudPackages
{
    my ($confBackup) = @_;

    my $remoteservices = EBox::Global->modInstance('remoteservices');
    unless ($remoteservices->eBoxSubscribed()) {
        return;
    }

    my $openvpn = EBox::Global->modInstance('openvpn');
    my $loaded = _loadSubscriptionBundle($remoteservices, $openvpn);
    unless ($loaded) {
        # could not install this packages without bundle
        return;
    }

    my @toInstall;

    my %cloudPackages = (
                         'ebox-cloud-prof',
                         'zentyal-security-updates',
                        );

    my $installedPackages = _debPackagesInBackup($confBackup);
    foreach my $package (@{ $installedPackages }) {
        if (exists $cloudPackages{$package}) {
            push @toInstall, $package;
            delete $cloudPackages{$package};
            if (keys %cloudPackages == 0) {
                last;
            }
        }
    }

    unless (@toInstall) {
        return;
    }

    _updateDebPackagesList(__('Updating package list to allow access to exclusive Zentyal Cloud packages'));

    my $msg = __('Install cloud packages');
    _aptInstall(\@toInstall, $msg);

    # No configure modules stage required because:
    # ebox-cloud-prof no needs configuration but only restoring
    # zentyal-security-updates is not a zentyal module
    my $cloudProfInstalled = grep { $_ eq 'cloud-prof'  } @toInstall;
    if ($cloudProfInstalled) {
        EBox::Backup->restoreBackup($confBackup, revokeAllOnModuleFail => 0,
                                    modsToRestore => [ 'cloud-prof' ]);
    }
}


sub _loadSubscriptionBundle
{
    my ($remoteservices, $openvpn) = @_;

    my $msg = __('Downloading subscription data');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    my $res;
    try {
        $openvpn->restartService();
        $remoteservices->restartService(); # to assure connection
        $res = $remoteservices->reloadBundle('force');
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    if ($res == 1) {
        # success!
        return 1;
    }

    if ($res == 0) {
        warning(__('Connection error when retrieving subscription bundle. Zentyal Cloud exclusive packages will not be installed'),
                 noBlocking => 1
                );

    } elsif ($res == 2) {
        warning(__('Cannot retrieve bundle because either installed ' .
                   'zentyal-remoteservices is outdated or only outdated ' .
                   'bundle is available in the cloud. Zentyal Cloud  ' .
                   'exclusive packages will not be installed'),
                noBlocking => 1,
               );
    } else {
        warning(__('Unknown error retrieving subscription bundle. Zentyal Cloud exclusive packages will not be installed'),
                noBlocking => 1,
               );
    }

    return 0;
}

sub _debPackagesInBackup
{
    my ($confBackup) = @_;

    my @packages;
    my $tmpDir = EBox::Backup->_unpackArchive($confBackup, 'debpackages');
    try {
        my $file = "$tmpDir/eboxbackup/debpackages";
        open (my $FH, "<", $file) or
            die "Error opening installed packages file $!";
        while (my $line = <$FH>) {
            # lines are like: ii apache2.2-common 2.2.14-1 Apache HTTP Server
            if ($line =~ m/\Aii\s+(.*?)\s/) {
                push @packages, $1;
            }
        }
        close $FH or
            die "Error closing isntalled packages file: $!";
    } finally {
        system "rm -rf $tmpDir";
    };

    return \@packages;
}


sub _configureModules
{
    my @modulesToConfigure = @_;

    unless (@modulesToConfigure) {
        return;
    }

    my %toConfigure = map { $_ => 1 } @modulesToConfigure;

    my $mgr = EBox::ServiceManager->new();
    my @orderedMods = @{$mgr->_dependencyTree()};

    my $PROGRESS_BAR;
    $usesX and
      local $SIG{PIPE} = 'IGNORE';

    my $pid;
    if ($usesX) {
        my $msg = __('Configuring modules');
        my $cmd = _zenityProgress($msg);
        $pid = open($PROGRESS_BAR, "|-");
        if ( $pid == 0 ) {
            # Child code
            exec { $cmd->[0] } @{$cmd};
            exit(2);
        }
    } else {
        print "\n";
    }

    my $i = 0;
    my $percent;
    foreach my $name (@orderedMods) {
        $i += 1;
        next unless (exists $toConfigure{$name});

        my $percent = ($i/(scalar @orderedMods)) * 100;
        $percent = sprintf("%i", $percent);

        if ($PROGRESS_BAR) {
            print $PROGRESS_BAR $percent . "\n" or
                _zenityProgressFail($!, $?);
            print $PROGRESS_BAR '#' . __x('Configuring modules: Current module {mod}', mod => $name) . "\n"
              or _zenityProgressFail($!, $?);
        } elsif (not $usesX) {
            print "\r";
            my $msg =  __x('Configuring modules {p} done. Current module {mod}',
                           p => "$percent%", mod => $name);
            print $msg;
            print "\n";
        }

        print "About to configure $name\n"; # DDDD
        my $module = EBox::Global->modInstance($name);
        $module->setInstalled();
        $module->setConfigured(1);
        $mgr->updateModuleDigests($name);

        try {
            $module->enableActions();
        } otherwise {
            my ($ex) = @_;
            my $err = $ex->text();
            $module->setConfigured(0);
            $module->enableService(0);
            my $msg = __x('Failed to configure module {name}: {err}. This could affect to the restore of other modules',
                          name => $module->name(),
                          err  => $err,
                         );
            warning($msg, noBlocking => 1);
        };

        $mgr->updateModuleDigests($name); # in ConfigureModuleController this is
            # call bef and after the enableActions
        print "Finished configuring $name\n"; # DDDD
    }

    if ($PROGRESS_BAR) {
        print $PROGRESS_BAR "100\n" or
            _zenityProgressFail($!, $?);
        close $PROGRESS_BAR or
            _zenityProgressFail($!, $?);

        if ($pid) {
            waitpid($pid, 0);
        }
    }

    my $saveChangesMsg = __('Finishing new modules configuration');
    print "Saving changes for new modules\n"; # DDD
    saveChanges($saveChangesMsg);
}


sub postRestoreConfigMangling
{
     # XXX here we will fix config items

}

# Stop any interrupting processes if required
sub _stopInterruptingProcesses
{
    my @interruptingModules = qw(events openvpn);
    try {
        my $gl = EBox::Global->getInstance(1);
        foreach my $mod (@interruptingModules) {
            if ( $gl->modExists($mod) ) {
                my $modInstance = $gl->modInstance($mod);
                $modInstance->stopService();
            }
        }
    } otherwise { };
}

sub _createFilesTmpDir
{
    my $filesTmpDir = filesTmpDir();
    if (not -d $filesTmpDir) {
        mkdir $filesTmpDir or
            throw EBox::Exceptions::Internal("Cannot create directory $filesTmpDir: $!");
    }

    my @dirsToCreate = (
        '/bin',
        '/boot',
        '/etc',
        '/home',
        '/lib',
        '/opt',
        '/root',
        '/sbin',
        '/selinux',
        '/srv',
        '/sys',
        '/tmp',

        '/usr/bin',
        '/usr/etc',
        '/usr/games',
        '/usr/include',
        '/usr/lib',
        '/usr/lib32',
        '/usr/lib64',
        '/usr/local',
        '/usr/sbin',
        '/usr/share',
        '/usr/src',

        '/var/cache',
        '/var/spool',
    );

    my @cmds;
    foreach my $dir (@dirsToCreate) {
        my $d = $filesTmpDir . $dir;
        push (@cmds, "mkdir -p --mode=755 $d");
    }
    EBox::Sudo::root(@cmds);

    return $filesTmpDir;
}

sub _downloadBackupMetadata
{
    my ($credentials, $date) = @_;
    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        return;
    }

    my $dstDir = metaTmpDir() ;
    if (not -d $dstDir) {
        mkdir $dstDir;
    }

    my $msg = __('Downloading backup metadata...');

    my $pulsatePid = _showUnanticipatedProgress($msg);
    try {
        EBox::EBackup::Subscribed::downloadDRMetadata($credentials, $date, $dstDir);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _fullDownload
{
    my ($toRestore, $metadata) = @_;
    my $fullDownload = 0;
    if ($metadata->{version} < 2) {
        # don't have size metadata so we use full
        return 1;
    }

    if ($toRestore->{filesIncludes}) {
        $fullDownload = 1;
    } else {
        my $total = 0;
        my $sizeToRestore;
        foreach my $domain (keys %{ $metadata->{backupDomains} }) {
            if (exists $metadata->{backupDomains}->{$domain}->{size}) {
                my $size = $metadata->{backupDomains}->{$domain}->{size};
                $total += $size;
                if ($toRestore->{$domain}) {
                    $sizeToRestore += $size;
                }
            }
        }
        my $threshold = $total/3;
        if (defined $sizeToRestore) {
            $fullDownload =  ($sizeToRestore >= $threshold);
        } else {
            # play safe
            $fullDownload = 1;
        }
    }

    return $fullDownload;
}


sub _pathsToRestoreByDomain
{
    my ($metadata, %toRestore) = @_;

    my $ebackup = EBox::Global->getInstance()->modInstance('ebackup');
    my %pathsByDomain;
    foreach my $domain (keys %toRestore ) {
        my $extraData =  $metadata->{backupDomains}->{$domain}->{extraDataDump};
        my $selections = $ebackup->_rawModulesBackupDomainsFileSelections($domain => 1);
        my @paths = map {
                if (exists $_->{includes}) {
                    @{  $_->{includes} };
                } else {
                    ()
                }
            } @{  $selections };
        if ($extraData) {
            push @paths, $ebackup->extraDataDir() . '/' . $domain;
        }

        $pathsByDomain{$domain} = \@paths;
    }

    return \%pathsByDomain;
}


sub _downloadBackupData
{
    my ($credentials, $date, $toRestore, $metadata) = @_;
    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        return;
    }

    my $urlParams = _remoteUrlParamsFromCredentials($credentials, 'data');

    my $dstDir = _createFilesTmpDir();

    if (_fullDownload($toRestore, $metadata)) {
        my $msg = __('Downloading the backup data');
        # restore all files, this is done to sepepd-up the process
        _downloadDuplicityFiles($urlParams, $date, '/',  $dstDir, $msg);
    } else {
        my %downloaded;
        my $pathsByDomain = _pathsToRestoreByDomain($metadata, %{ $toRestore });
        foreach my $domain (keys %{ $toRestore }) {
            my $printableName =  $metadata->{backupDomains}->{$domain}->{printableName};
            $printableName or
                $printableName = $domain;

            my @srcs = sort @{  $pathsByDomain->{$domain} };
            foreach my $src (@srcs) {
                if ($downloaded{$src}) {
                    next;
                }
                $downloaded{$src} = 1;

                my $msg =  __x('Downloading  {src} backup data for {dom}',
                               src => $src,
                               dom => $printableName);

                # adjust src and dst if needed
                my $dst = $dstDir . '/' . $src;
                while (($src ne '/') and not EBox::Sudo::fileTest('-d',  File::Basename::dirname($dst))) {
                    $src = File::Basename::dirname($src);
                    $dst = $dstDir . '/' . $src;
                }

                try {
                    _downloadDuplicityFiles($urlParams, $date, $src,  $dst, $msg);
                } otherwise {
                    my $errorMsg = __x('Error downloading data for backup domain: {dom}. The domain will not be fully restored',
                                       dom => $printableName,
                                 );
                    warning($errorMsg);
                };
            }
         }
    }
}

sub _downloadConfigurationBackupFromFilesArchive
{
    my ($credentials, $date, $file, $dst, $msg) = @_;

    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        return;
    }

    $msg or
        $msg = __('Downloading the backup configuration');
    my $urlParams = _remoteUrlParamsFromCredentials($credentials, 'data');

    _downloadDuplicityFiles($urlParams, $date, $file, $dst, $msg);
}


sub _downloadDuplicityFiles
{
    my ($urlParams, $date, $src, $dstDir, $msg) = @_;

    EBox::info($msg);
    EBox::info("Restoring $src to $dstDir ");

    my $done = 0;
    while (not $done) {
        my $pulsatePid = _showUnanticipatedProgress($msg);
        try {
            my $ebackup = EBox::Global->getInstance()->modInstance('ebackup');
            $ebackup->restoreFile($src, $date, $dstDir, $urlParams);
            $done = 1;
        } catch EBox::Exceptions::EBackup::BadSymmetricKey with {
            _retrySymmKey($urlParams);            
        }otherwise {
            my $ex = shift @_;
            EBox::error("Error restoring file $src to $dstDir: $ex");
            $ex->throw();
        } finally {
            _finishUnanticipatedProgress($pulsatePid);
        };
    }
}

sub _fileFromBackup
{
    my ($file) = @_;
    return filesTmpDir() . '/' . $file;
}

sub _getConfigBackup
{
    my ($credentials, $metadata, $date) = @_;

    my $dstFile = tmpDir() . '/backup-config';

    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        my $msg =  __('Downloading configuration');;
        my $pulsatePid = _showUnanticipatedProgress($msg);
        try {
            _downloadBasicConfigurationBackup($credentials, $date, $dstFile);
        } finally {
            _finishUnanticipatedProgress($pulsatePid);
        };

        return $dstFile;
    }

    if ($metadata->{version} >= 2) {
        my $bakFile;      
        my $done = 0;
        while (not $done) {
            try {
                $bakFile = EBox::EBackup::Subscribed::downloadConfigurationBackup($credentials, $date, $dstFile);
                $done = 1;
            } catch EBox::Exceptions::EBackup::BadSymmetricKey with {
                _retrySymmKey(_remoteUrlParamsFromCredentials($credentials));
            };
        }

        if ($bakFile and (-e $bakFile)) {
            return $bakFile;
        } else {
            fatal("Cannot found stored configuration fire in cloud");
        }
    }

    # XXX version 1 compability and fallback. Remove in the future
    my $ebackup = EBox::Global->modInstance('ebackup');
    my $backupFile =  $ebackup->includedConfigBackupPath();
    try {
        _downloadConfigurationBackupFromFilesArchive($credentials, $date, $backupFile, $dstFile);
    } catch EBox::Exceptions::EBackup::FileNotFoundInBackup with {
        my ($ex) = @_;
        if ($ex->file() eq $backupFile ) {
            # check if we are using a 2.0, trying to download a 2.0
            # configuration fule
            $backupFile =~ s/zentyal/ebox/g;
            try {
                _downloadConfigurationBackupFromFilesArchive($credentials, $date, $backupFile, $dstFile, __('Looking for a version 2.0.X backup'));
                fatal("You are likely trying to restore a backup done in a version 2.0.X; please retry with a 2.0.X installer", 1);
            } otherwise {
                # backup conf for 2.0 not foud, throw original excpetion
                $ex->throw(); 
            };
        } else {
            $ex->throw(); # no fallback, we rethrow the exception
        }
    };    

    return $dstFile;
}

sub askBackupDate
{
    my ($credentials, $restoreLast) = @_;

    if ($credentials->{type} eq 'basic') {
        return _basicBackupDate($credentials, $restoreLast);
    }

    # extractions of date could take a long time, maybe we can put a progress
    # widget there
    my $commonName = $credentials->{commonName};
    my $ebackup = EBox::Global->modInstance('ebackup');

    my $msg = __('Retrieving backup collection status ...');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    my @dates;
    my $lastDate;
    my $fail = 0;
    try {
        my $urlParams = _remoteUrlParamsFromCredentials($credentials, 'data');
        if ($restoreLast) {
            $lastDate= $ebackup->lastBackupDate($urlParams);
        } else {
            my $status = $ebackup->remoteStatus($urlParams);
            my %times = map { str2time($_->{date}) => $_->{date} } @{$status};
            my @sortDates = sort { $b <=> $a } keys(%times);
            @dates = map { $times{$_}; } @sortDates;
        }
    } otherwise {
        my $ex = shift;
        warning($ex);
        $fail = 1;
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    if ($fail) {
        return undef;
    }

    if ($lastDate) {
        print __x('Last backup date was: {date}', date => $lastDate) . "\n";
        return $lastDate;
    }

    if (not @dates) {
        # fatal(__x(
        #           'No backups found for server {server}',
        #           server => $credentials->{commonName}
        #          )
        #      );
        return undef;
    }

    return _backupDateInput($commonName, \@dates);
}

sub _basicBackupDate
{
    my ($credentials, $restoreLast) = @_;
    my $remoteBackup = EBox::RemoteServices::ProxyBackup->new(
                                          user => $credentials->{username},
                                          password => $credentials->{password},
                                                             );
    my $commonName = $credentials->{commonName};
    my $allBackups = $remoteBackup->listRemoteBackups();
    if (not exists $allBackups->{$commonName}) {
        warning(__x('No automatic configuration backups were made for the server {s}',
                  s => $commonName
                 )
            );
    }

    my $backups = $allBackups->{$commonName};
    if ($restoreLast) {
        return _lastBasicBackupDate($backups);
    }

    my @dates = map {
        $_->{Date}
    } values %{ $backups };

    return _backupDateInput($commonName, \@dates);
}


sub _lastBasicBackupDate
{
    my ($backups) = @_;

    my $lastDate;
    my $lastDateStr;
    while (my ($name, $attrs) = each %{ $backups }) {
        my ($dateStr) = split '\+', $attrs->{Date};
        my $date = DateTime->from_epoch(epoch => str2time($dateStr));

        if ((not defined $lastDate) or ($date > $lastDate)) {
            $lastDate = $date;
            $lastDateStr = $attrs->{Date};
        }
    }

    print __x('Last backup date was: {date}', date => $lastDateStr) . "\n";
    return $lastDateStr;
}

sub _backupDateInput
{
    my ($commonName, $dates) = @_;
    my $chosen;
    if ($usesX) {
        # first date in the list enabled
        my $firstDate = $dates->[0];
        $dates->[0] = {
            item => $firstDate,
            enabled => 1,
        };

        $chosen = _zenityList(__x('Choose date to restore the backup from server {cn}',
                                  cn => $commonName
                                 ),
                                __('Date'),
                                  0, $dates);
    } else {
        $chosen = _terminalDateInput($commonName, $dates);
    }

    return $chosen;
}


sub _downloadBasicConfigurationBackup
{
    my ($credentials, $date, $dstFile) = @_;
    my $remoteBackup = EBox::RemoteServices::ProxyBackup->new(
                                          user => $credentials->{username},
                                          password => $credentials->{password},
                                                             );
    my $commonName = $credentials->{commonName};
    my $allBackups = $remoteBackup->listRemoteBackups();
    if (not exists $allBackups->{$commonName}) {
        fatal(__x(
              'No automatic configuration backups were done for the server {s}',
                  s => $commonName,
                )
             );
    }

    my $backups = $allBackups->{$commonName};

    my $chosen;
    while (my ($name, $attrs) = each %{ $backups }) {
        if ($attrs->{Date} eq $date) {
            $chosen = $name;
            last;
        }
    }

    unless (defined $chosen) {
        fatal(__x('No configuration backups were made for the date {d} in {s} server',
              s => $commonName, d => $date));
    }

    my $tmpFile = $remoteBackup->downloadRemoteBackup($commonName, $chosen);
    EBox::Sudo::command("mv -f '$tmpFile' '$dstFile'");
    return $dstFile;
}

sub clearTmpDir
{
    my $tmpDir = tmpDir();

    EBox::Sudo::silentRoot("rm -rf $tmpDir");
}

sub createTmpDir
{
    my $tmpDir = tmpDir();
    unless ( -d $tmpDir ) {
        mkdir($tmpDir);
    }
}


sub _checkServerCN
{
    my ($serverCN, $servers, $force_r) = @_;

    if ($force_r->{noCloudLogin}) {
        return;
    }

    my $serverFound = grep { $serverCN eq $_ } @{ $servers };

    unless ($serverFound) {
        fatal(__x('The server {server} is not registered in Zentyal Cloud',
                  server => $serverCN));
    }
}


sub _getDomainsInBackup
{
    my ($ebackup, $credentials, $date) = @_;

    my $listPath = _fileFromBackup($ebackup->enabledDomainsListPath());
    if (not -f $listPath) {
        EBox::warn('No backup domain lists, assuming all were backed-up');
        return undef;
    }

    my @domains = split ',', File::Slurp::read_file($listPath);

    my $domainsHash = { map { $_ => 1 } @domains };

    return $domainsHash;
}

sub _backupDomainsAvailableByPrintableName
{
    my ($metadata) = @_;

    my %domains;
    while(my ($key, $data) = each %{$metadata->{backupDomains}}) {
        # ignore failed backups
        if ($data->{failed}) {
            next;
        }
        $domains{$data->{printableName}} = $key;
    }

    return \%domains;
}

sub terminalPrompt
{
    my ($msg, $hide) = @_;

    if ($hide) {
        ReadMode('noecho');
    }

    my $input = undef;
    while (not defined $input) {
        print  $msg;
        $input = readline(*STDIN);
        print "\n";

        chomp $input;
        $input =~ s/^\s+//;
        $input =~ s/\s+$//;

        if ($input eq '') {
            $input = undef;
            print __('Please, enter a value');
            print "\n";
        }
    }

    if ($hide) {
        ReadMode('normal');
    }

    return $input;
}


sub terminalQuestion
{
    my ($msg) = @_;
    $msg .= '(y/n):';
    my $answer;
    while (not $answer) {
        $answer = terminalPrompt($msg);
        if (($answer eq 'yes') or ($answer eq 'y')) {
            return 1;
        } elsif (($answer eq 'no') or $answer eq 'n') {
            return 0;
        } else {
            print __('Please answer yes or no') , "\n";
            $answer = undef;
        }
    }
}

sub _terminalProgressIndicator
{
    my ($progressIndicator, $msg) = @_;
    my $percent = 0;
    print "\n";
    while ($percent < 100) {
        print "\r$msg: $percent%";
        $percent = $progressIndicator->percentage();
        sleep 1;
    }
    print "\r$msg: $percent%\n";

    return $progressIndicator->retValue();
}


sub _terminalDateInput
{
    my ($commonName, $dates) = @_;

    print __x('Backup dates for server {cn}', cn => $commonName);
    print "\n------------------------------------------\n";
    foreach my $date (@{ $dates }) {
        print "$date\n";
    }

    my %validDates= map { $_ => 1 } @{ $dates };

    my $selected = undef;
    while (not defined $selected) {
        print "\n";
        $selected = terminalPrompt(__('Enter backup date to restore:'));

        unless (exists $validDates{$selected}) {
             print __x('Invalid date: {d}. Try again', d => $selected);
             print "\n";
             $selected = undef;
         }
    }

    return $selected;
}

sub _zenityQuote
{
    my ($text) = @_;

    $text = shell_quote($text);

    if ($text =~ m/a href/) {
        # GTK needs these changes in URLs
        # escape ampersand
        $text =~ s/&/&amp;/g;
        # remove target attr
        $text =~ s/target=".*?"//g;
    }

    return $text;
}

sub _zenityCommonArgs
{
    my ($width) = @_;
    defined ($width) or $width = 300;

    if ( wantarray ) {
        my @args = "--width=$width";
        push(@args, '--title=' . _zenityTitle(1));
        push(@args, _zenityIcon());
        return @args;
    } else {
        my $args = "--width=$width --title " . _zenityTitle() . ' ';
        $args .= _zenityIcon() . ' ';
        return $args;
    }
}

sub _zenityTitle
{
    my ($notQuote) = @_;
    if ( $notQuote ) {
        return 'Zentyal Disaster Recovery';
    } else {
        return _zenityQuote('Zentyal Disaster Recovery');
    }
}

sub _zenityIcon
{
    my $path = EBox::Config::www() . 'favicon.ico';
    if (-r $path) {
        return "--window-icon=$path";
    }

    return '';
}

# Type: info | warning | error
#
sub _zenityMessage
{
    my ($type, $text) = @_;

    my $commonArgs = _zenityCommonArgs();
    $text = _zenityQuote($text);
    my $cmd = qq{zenity --$type $commonArgs --text=$text};

    EBox::Sudo::command($cmd);
}

sub _zenityEntry
{
    my ($text, $hide) = @_;

    $text = _zenityQuote($text);
    my $commonArgs = _zenityCommonArgs();
    my $cmd = qq{zenity --entry $commonArgs --text=$text};
    if ($hide) {
        $cmd .= ' --hide-text';
    }

    my $answer = undef;
    while (not defined $answer) {
        try {
            my $output = EBox::Sudo::command($cmd);
            $answer = _zenityAnswerFromOutput($output);
            if ($answer eq '') {
                $answer = undef;
            }
        } catch EBox::Exceptions::Command with {
            my $ex = shift;
            if ($ex->exitValue() == 1) {
                # cancel button pressed
                _zenityUserAbort();
            } else {
                $ex->throw();
            }
        };

        unless (defined $answer) {
            _zenityMessage('warning', __('This entry is mandatory to continue the restoring process. Retry'));
        }
    }

    return $answer;
}

sub _zenityQuestion
{
    my ($text) = @_;

    $text = _zenityQuote($text);
    my $commonArgs = _zenityCommonArgs();
    my $cmd = qq{zenity --question $commonArgs --text=$text};

    my $ret;
    try {
        EBox::Sudo::command($cmd);
        $ret = 1;
    } catch EBox::Exceptions::Command with {
        my $ex = shift;
        if ($ex->exitValue() == 1) {
            # exit code signals 'no' answer
            $ret = 0;
        } else {
            # exit code signals error in application
            $ex->throw();
        }
    };

    return $ret;
}

sub _zenityList
{
    my ($text, $column, $multiple, $list, %params) = @_;
    $text = _zenityQuote($text);
    my $enabledByDefault = $params{enabledByDefault};

    my $commonArgs = _zenityCommonArgs();

    my $cmd = qq{zenity --height 250 --list $commonArgs --text=$text };
    if ($multiple) {
        $cmd .=  "--checklist";
    } else {
        $cmd .= " --radiolist";
    }

    $cmd .=  q{ --column } . __('Selection') . qq{ --column "$column" };

    foreach my $element (@{ $list}) {
        my $enabled = $enabledByDefault;

        my $item;
        if (ref $element eq 'HASH') {
            $item = $element->{item};
            $enabled = $element->{enabled};
        } else {
            $item = $element;
        }

        if ($enabled) {
            $cmd .= qq{ TRUE "$item"};
        } else {
            $cmd .= qq{ FALSE "$item"};
        }
    }

    my $answer = undef;
    while (not defined $answer) {
        try {
            my $output = EBox::Sudo::command($cmd);
            $answer = _zenityAnswerFromOutput($output);
            if ($answer eq '') {
                $answer = undef;
            }
        } catch EBox::Exceptions::Command with {
            my $ex = shift;
            if ($ex->exitValue() == 1) {
                # cancel button pressed
                _zenityUserAbort();
            } else {
                $ex->throw();
            }
        };

        if (not defined $answer) {
            _zenityMessage('warning', __('This entry is mandatory to carry on the restoring process. Choose from the list'));
        }
    }

    if ($multiple) {
        my @answerList = split '\|', $answer;
        return \@answerList;
    }

    return $answer;
}


sub _zenityAnswerFromOutput
{
    my ($output) = @_;
    my $answer = $output->[0];
    defined $answer or
        return undef;

    chomp $answer;

    $answer =~ s/^\s*//;
    $answer =~ s/\s*$//;
    # Decoding UTF8 strings if any...
    utf8::decode($answer);
    return $answer;
}

sub _zenityProgress
{
    my ($text, $pulsate) = @_;

    my @commonArgs = _zenityCommonArgs($pulsate ? 300 : 400);

    my @args = ('--auto-close');
    if ($pulsate) {
        push(@args, '--pulsate');
    } else {
        push(@args, '--auto-kill');
    }

    my @cmd = ('zenity', '--progress');
    push(@cmd, @commonArgs);
    push(@cmd, @args);
    push(@cmd, "--text=$text");
    return \@cmd;
}

sub _zenityProgressIndicator
{
    my ($progressIndicator, $text) = @_;
    my $cmd = _zenityProgress($text);

    local $SIG{PIPE} = 'IGNORE';
    my $PR;
    my $pid = open ($PR, '|-');
    select ((select ($PR), $|=1)[0]); #autoflush
    if ( $pid == 0 ) {
        # Child code
        exec { $cmd->[0] } @{$cmd};
        exit(2);
    }
    my $percent = 0;
    while (not $progressIndicator->finished()) {
        $percent = $progressIndicator->percentage();
        if ($percent) {
            # Avoid progress bar premature finish:
            $percent = 99 if ($percent >= 100);

            print $PR "$percent\n" or
                _zenityProgressFail($!, $?);
        }
        my $message = $progressIndicator->message();
        if ($message) {
            # Avoid long lines that make the dialog ugly
            if ($message =~ /Downloading /) {
                my @tokens = split (' ', $message);
                $message = "$tokens[0] $tokens[3] ($tokens[4])\n";
            } elsif ($message =~ /Unpacking /) {
                $message =~ s/\(from .*\)\s//;
            }
            $message =~ s/^\s//;

            print $PR "#$text" . '\n' . "$message\n" or
                _zenityProgressFail($!, $?);
        }
        sleep 1;
    }

    close $PR or
        _zenityProgressFail($!, $?);

    if ($pid) {
        waitpid($pid, 0);
    }

    return $progressIndicator->retValue();
}

sub _zenityProgressFail
{
    my ($err, $exitValue) = @_;
    if ($err eq 'Broken pipe' and ($exitValue == 0)) {
        _zenityUserAbort();
    } elsif ($err eq 'Broken pipe') {
        # error closing progress bar. We ignore it
        return;
    } else {
        fatal("$err. Exit code: $exitValue");
    }
}


sub _showUnanticipatedProgress
{
    my ($msg) = @_;
    if ($usesX) {
        return _zenityPulsate($msg);
    } else {
        print $msg . "\n";
        print __('Please wait') . "\n";;
        return undef;
    }
}

sub _finishUnanticipatedProgress
{
    my ($pulsatePid) = @_;

    if ($usesX) {
        if (defined $pulsatePid) {
            _zenityPulsateClose($pulsatePid);
        }
    } else {
        print __('Finished') . "\n";
    }
}


sub _zenityPulsate
{
    my ($text) = @_;

    my $pid = fork();
    if ($pid) {
        # parent
        return $pid;
    }

    # child code
    chdir '/'               or die "Can't chdir to /: $!";
    open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null';

    die "Can't start a new session: $!" if setsid == -1;
    open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";

    my $zenityCmd = _zenityProgress($text, 1);
    $pid = open my $PROC, "|-";
    if ( $pid == 0 ) {
        # Child code
        exec { $zenityCmd->[0] } @{$zenityCmd};
        exit(2);
    }

    while (1) {
        print $PROC 1;
    }
    close $PROC;

    if ($pid) {
        waitpid($pid, 0);
    }

    exit(0);
}


sub _zenityPulsateClose
{
    my ($pulsatePid) = @_;
    # Send SIGABRT
    kill(6, $pulsatePid);

    # XXX use kill -9 if it does not close

    # To avoid zombie processes, this is a blocking operation
    if ($pulsatePid) {
        waitpid($pulsatePid, 0);
    }
}

sub _zenityUserAbort
{
    my $msg = __('Restoring process aborted upon user request');
    fatal($msg);
}


sub _remoteUrlParamsFromCredentials
{
    my ($credentials, $targetType) = @_;

    my $target = $credentials->{server} . '/' . $credentials->{commonName} ;
    $target .= "/$targetType";
    my %params = (
        method => $credentials->{method},
        user   => $credentials->{username},
        password => $credentials->{password},
        target => $target,
        encValue => $credentials->{encValue},
        encSelected => $credentials->{encSelected},
        alternativePassword => 1,
        credentials => $credentials,
    );

    return \%params;
}

# Perform saving changes
sub saveChanges
{
    my ($msg, $retry) = @_;
    defined($msg) or $msg =  __('Saving configuration changes');
    defined($retry) or $retry = 1;

    my $global = EBox::Global->getInstance();
    if (not $global->unsaved()) {
        return;
    }

    my $progressIndicator = $global->prepareSaveAllModules();

    my $retValue = progress($progressIndicator, $msg);
    if ($retValue != 0) {
        my $errorMsg = $progressIndicator->errorMsg();
        if ($retry) {
            # first try, save changes failed, do a retry
            $errorMsg or $errorMsg = 'Unknown';
            EBox::warn("Error saving changes (will retry): $errorMsg");
            saveChanges($msg, 0);
        } else {
            if ($errorMsg) {
                my $msg = $errorMsg . "\n";
                $msg .= __('Error saving configuration changes; some Zentyal modules would remain in a unknown state');
                error($msg);
                return;
            } else {
                EBox::warn("Progress indicator for saveChanges does not specify any error but has returned the following value: $retValue.");
            }
        }
    }
}

# Regenerate the ebackup cache for file list that it is not done
# already for restarting the module so we have to do it by hand
sub regenerateCaches
{
    my $msg = __('Regenerating file list cache');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        my $ebackup = EBox::Global->modInstance('ebackup');
        $ebackup->remoteGenerateListFile();
    }  catch EBox::Exceptions::NotConnected with {
        warning(
                __('Cannot connect to the Cloud to regenerate backup list. Please try again later.'),
                noBlocking => 1
               );
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _xauthCookie
{
    unless ($usesX) {
        return undef;
    }

    my $cmd = 'xauth list';
    my @output = `$cmd`;
    foreach my $line (@output) {
        chomp $line;
    }
    return \@output;
}

sub _xauthEBox
{
    my ($cookieList) = @_;

    unless($usesX) {
        return;
    }

    my $xauthFile = '/var/lib/zentyal/.Xauthority';
    EBox::Sudo::root("rm -f $xauthFile");
    EBox::Sudo::root("touch $xauthFile");
    EBox::Sudo::root("chown ebox.ebox $xauthFile");

    foreach my $cookie (@{ $cookieList }) {
        EBox::Sudo::command("xauth -f $xauthFile add $cookie");
    }
}

sub progress
{
    my ($progressIndicator, $msg)  = @_;

    if (not $progressIndicator->started()) {
        $progressIndicator->runExecutable();
    }

    if ($usesX) {
        return _zenityProgressIndicator($progressIndicator, $msg);
    } else {
        return _terminalProgressIndicator($progressIndicator, $msg);
    }
}

sub getUserAndPasswordAndServers
{
    my ($user, $password, $force_r) = @_;

    if ($force_r->{noCloudLogin}) {
        return {
            user     => undef,
            password => undef,
            servers  => [],
        };
    }

    my $remoteServices = EBox::Global->modInstance('remoteservices');
    my $servers;

    while (not ($user and $password)) {
        if (not $user) {
            $user = input(__('Zentyal Cloud User'));
        }
        if (not $password) {
            $password = password(__('Zentyal Cloud Password'));
        }

        try {
            $servers = serverList($remoteServices, $user, $password);
        } catch EBox::Exceptions::External with {
            my $ex = shift;
            error("$ex");
            $user = $password = '';
        };
    }

    unless (defined $servers and @{$servers}) {
        $servers = serverList($remoteServices, $user, $password);
        unless ( defined $servers and @{$servers} ) {
            fatal(__x("The account {user} do not have any registered Zentyal servers",
                      user => $user));
        }
    }

    return {
        user => $user,
        password => $password,
        servers => $servers,
    };
}

sub getCredentials
{
    my ($user, $password, $servers, $serverCN, $force_r) = @_;

    if ($serverCN) {
        _checkServerCN($serverCN, $servers, $force_r);
    } else {
        $serverCN = askServerCN($servers);
    }

    my $remoteServices = EBox::Global->modInstance('remoteservices');
    my $credentials = backupCredentials(
                                        remoteServices => $remoteServices,
                                        username       => $user,
                                        password       => $password,
                                        serverCN       => $serverCN,
                                        force          => $force_r,
                                       );

    if ($credentials->{type} eq 'basic') {
        my $infoMsg = __s('If you had purchased the Zentyal Disaster Recovery service, besides the configuration you are about to recover, you could have restored the data of the modules.');
        info($infoMsg);
    }

    _setupPasswords($credentials);
    return $credentials;
}

sub getEncryption
{
    my ($credentials, $metadata, %params) = @_;

    if ($credentials->{type} eq 'basic') {
        return;
    }

    my $noEncryption      = $params{noEncryption};
    my $symmetricPassword = $params{symmetricPassword};
    my $encryptionKey     = $params{encryptionKey};
    my $keyPassphrase     = $params{keyPassphrase};

    if ((not $noEncryption) and
        (not defined $symmetricPassword) and
        (not defined $encryptionKey) )  {

        if (_backupUsesEncryption($credentials, $metadata)) {
            my $dialogMsg =  __x(
                  'Enter password used to encrypt back up {ser}',
                   ser => $credentials->{commonName});
            $symmetricPassword = password($dialogMsg); # 
        }
    }

    $credentials = addEncryptionToCredentials($credentials,
                symmetricPassword => $symmetricPassword,
                encryptionKey     => $encryptionKey,
                keyPassphrase     => $keyPassphrase,
                );

    if ($symmetricPassword) {
        # udpate passwords with symmetric password
        _setupPasswords($credentials);
    }
}

sub _retrySymmKey
{
    my ($urlParams) = @_;
    my $credentials = $urlParams->{credentials};
    my $newKey;

    my $dialogMsg =  __x(
        'Incorrect password. Please, enter the correct password used for encrypt {ser}.',
        ser => $credentials->{commonName});
    $newKey = password($dialogMsg);

    $credentials = addEncryptionToCredentials($credentials,
                symmetricPassword => $newKey,
                encryptionKey     => $credentials->{encryptionKey},
                keyPassphrase     => $credentials->{keyPassphrase},
                );
    _setupPasswords($credentials);
}

sub _backupUsesEncryption
{
    my ($credentials, $metadata) = @_;
    if ($metadata) {
        my $encType = $metadata->{encryptionType};
        return ($encType eq 'symmetric');
    }

    return EBox::EBackup::Subscribed::collectionEncrypted($credentials);
}

sub readMetadataFile
{
    my ($path) = @_;
    my ($yaml) = YAML::XS::LoadFile($path);

    return $yaml->{backup};
}

sub getBackupDomainsToRestore
{
    my ($credentials, $metadata, $restoreAll, $domainsCli) = @_;

    my @domainsCli = @{ $domainsCli };
    my $domains;

    if ($credentials->{type} eq 'subscribed') {
        if ($restoreAll) {
            $domains = { map { $_ => 1 } keys %{ $metadata->{backupDomains} } };
        } elsif (not @domainsCli) {
            # ask to the user
            $domains = askDomainsToRestore($credentials, $metadata);
        } else {
            $domains = { map { $_ => 1 } @domainsCli };
        }

    } else {
        @domainsCli = grep { $_ ne 'configuration' } @domainsCli;
        if (@domainsCli) {
            fatal (__x('The following backup domains could not be restored from a basic subscription: {domains}',
                       domains => "@domainsCli"));
        }
        $domains = { configuration => 1 };
    }

    return $domains;
}


sub _logStartProcess
{
    my ($credentials, $date, $toRestore) = @_;
    my $commonName = $credentials->{commonName};
    my $domains = join ', ', keys %{ $toRestore };
    my $msg = "Restore process started. Using data from $commonName at $date. Backup domains: $domains";
    EBox::info($msg);
}

sub _apachePort
{
    my $apache = EBox::Global->getInstance(1)->modInstance('apache');
    return $apache->port();
}

sub takeFilesMD5
{
    my @files = ('/etc/passwd',
                 '/etc/shadow',
                );
    foreach my $file (@files) {
        $filesMD5{$file} = _fileMD5($file);
    }
}

# doesnt discriminate between added, removed and modfied 
sub checkFilesMD5
{
    my @changed;
    while (my ($file, $oldMd5) = each %filesMD5) {
        my $newMD5 = _fileMD5($file);
        if (defined $oldMd5 and defined $newMD5) {
            if ($oldMd5 ne $newMD5) {
                # changed
                push @changed, $file;
            }
        } elsif (defined $oldMd5 and not defined $newMD5) {
            # removed
            push @changed, $file;
        } elsif (not defined $oldMd5 and defined $newMD5) {
            # added
            push @changed, $file;
        }
    }

    my %changed =    map { $_ => 1 } @changed;
    return \%changed;
}

sub _fileMD5
{
    my ($file)= @_;
    my $fileSum;
    if (EBox::Sudo::fileTest('-r', $file)) {
        my $md5Cmd= "md5sum '$file'";
        try {
            my $output  =  EBox::Sudo::root($md5Cmd);
            my $outputLine = $output->[0];
            ($fileSum) = split '\s', $outputLine; # removing file name
        } catch EBox::Exceptions::Command with {
                my ($ex) = shift @_;
                my $error = join '', @{ $ex->error() };
                EBox::error("error making m5sum of file: $file");
        };
    } else {
        EBox::error("Cannot get MD5 of file $file, because it could not be read");
    }

    return $fileSum;
}


sub setHostname
{
    my ($metadata) = @_;
    my $hostname = exists $metadata->{hostname} ?
                          $metadata->{hostname} : undef;
    if ($hostname) {
        my $cmd = CHANGE_HOSTNAME_SCRIPT . ' ' . $hostname;
        EBox::Sudo::root($cmd);
    } else {
        EBox::info("No hostname metadata found");
    }
}

sub _finishedChangedFilesWarnings
{
    my ($files) = @_;

    if ($files->{'/etc/password'}) {
        # XXX check wether  the local user is the same or not
        warning(
            __(
                'The local password file has changed, the local users and their password could have been changed. We reccomend you to logut and login again with a valid user to avoid user identity problems.'
               )
           );
    } elsif ($files->{'/etc/shadow'}) {
        warning(
     __('The shadow password file was restored; your local user password could have been changed')
           );
    }
}

sub _finishedHostnameFilesWarnings
{
    my ($changedFiles) = @_;
    if ($changedFiles->{'/etc/hostname'} or $changedFiles->{'/etc/hosts'}) {
        warning(
            __('No hostname infromation found in metadata but hostname configuration files changed; please fix your hostname manually or with the Zentyal option found at System -> General.')
           );
    }
}

sub showPendingMessages
{
    foreach my $pending (@pendingMessages) {
        my $type    = $pending->{type};
        my $params = $pending->{'params'};
        if ($type eq 'info') {
            info(@{ $params });
        } elsif ($type eq 'warning') {
            warning(@{ $params });
        } elsif ($type eq 'error') {
            error(@{ $params });
        }
    }
}

sub finishedMessages
{
    my ($credentials, $metadata) = @_;
    showPendingMessages();

    my $changedFiles = checkFilesMD5();
    if (keys %{ $changedFiles }) {
        _finishedChangedFilesWarnings($changedFiles);
        if (not $metadata->{hostname}) {
            _finishedHostnameFilesWarnings($changedFiles);
        }
    }

    # XXX add warnings of changed apache port
    # XXX add warnings of changed ebox modules?
    finalMessage($credentials);
}

# The last message to finish the restore
sub finalMessage
{
    my ($credentials) = @_;

    my $msg = '';
    if ( $credentials->{type} eq 'basic' ) {
        $msg = __s('Your configuration backup is now restored!') . "\n\n" .
               __s('Perhaps you could be interested in the Zentyal Disaster Recovery service? This service guarantees that your most business critical data will be stored in a safe remote location and can be recovered easily in case of a disaster.');
    } else {
        $msg = __('Your full backup is now successfully restored!');
    }

    my $url = 'https://localhost';
    my $port = _apachePort();
    if ($port != 443) {
        $url .= ":$port";
    }

    $msg .= "\n\n";
    $msg .= __x('You can now login at {url} to manage your recovered host.',
                 url => $url);

    info($msg);
}

sub info
{
    my ($msg, %params) = @_;
    my $noBlocking = delete $params{noBlocking};
    my $noLog      = delete $params{noLog};

    unless ($noLog) {
        EBox::info($msg);
    }

    if ($usesX) {
        if ($noBlocking) {
            print "$msg\n";
            push @pendingMessages, {
                type => 'info',
                params => [$msg, %params, noLog => 1]
               };
        } else {
            _zenityMessage('info', $msg);
        }
    } else {
        print "$msg\n";
    }
}

sub error
{
    my ($msg, %params) = @_;
    my $exception = $params{exception};
    my $noBlocking = delete $params{noBlocking};
    my $noLog      = delete $params{noLog};

    unless ($noLog) {
        if (defined $exception ) {
            EBox::error("Unexpected error: $exception");
        } else {
            EBox::error($msg);
        }
    }

    if ($usesX) {
        if ($noBlocking) {
            print STDERR "$msg\n";
            push @pendingMessages, {
                type => 'error',
                params => [$msg, %params, noLog => 1]
               };
        } else {
            _zenityMessage('error', $msg);
        }
    } else {
        print STDERR "$msg\n";
    }
}

sub warning
{
    my ($msg, %params) = @_;

    my $noBlocking = delete $params{noBlocking};
    my $noLog      = delete $params{noLog};

    unless ($noLog) {
        EBox::warn($msg);
    }

    if ($usesX) {
        if ($noBlocking) {
            print __x('Warning: {msg}', msg => "$msg\n");
            push @pendingMessages, {
                type => 'warning',
                params => [$msg, %params, noLog => 1]
               };
        } else {
            _zenityMessage('warning', $msg);
        }
    } else {
        print __x('Warning: {msg}', msg => "$msg\n");
    }
}

sub input
{
    my ($msg, $masked) = @_;

    if ($usesX) {
        return _zenityEntry($msg, $masked);
    } else {
        return terminalPrompt("$msg: ", $masked);
    }
}

sub password
{
    my ($msg) = @_;

    input($msg, 1);
}

sub showException
{
    my ($exception, $showRealMsg) = @_;

    my $msg;
    if ($showRealMsg) {
        $msg = $exception;
    } else {
        $msg = __('Sorry, an unexpected error has occurred. Please contact support and check the /var/log/zentyal/zentyal.log file for further details.');        
    }

    error($msg, exception => $exception);

    return $msg;
}

my $_fatalShow = 0;
sub fatal
{
    my ($input, $showRealMsg) = @_;

    EBox::error("Restore fatal error: $input");

    if (not $_fatalShow) {
        my $msg = showException($input, $showRealMsg);
        $_fatalShow = 1;
        die $msg;
    }

    die __('Restore process aborted');
}

