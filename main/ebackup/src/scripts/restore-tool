#!/usr/bin/perl
# Copyright (C) 2010-2011 eBox Technologies S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use warnings;

use EBox;
use EBox::Backup;
use EBox::Config;
use EBox::EBackup::DBRestore;
use EBox::EBackup::Password;
use EBox::EBackup::Subscribed;
use EBox::Gettext;
use EBox::Global;
use EBox::NetWrappers;
use EBox::RemoteServices::ProxyBackup;
use EBox::ServiceManager;
use EBox::Sudo;
use EBox::Exceptions::Command;
use Error qw(:try);
use Getopt::Long;
use POSIX 'setsid';
use Term::ReadKey;
use Date::Parse;
use DateTime;
use String::ShellQuote;
use YAML::XS;

use constant NTP_SERVER     => 'pool.ntp.org';

my $usesX = 1; # flag to signal whether graphical environment is available

my $xauthCookie;
my $usage = 0;
my ($user, $password, $serverCN);
my $restoreLast = 0;
my @toRestoreCli = ();
my $noEncryption;
my $symmetricPassword = undef;
my $encryptKey = undef;
my $keyPassphrase;
my $error = 0;

parseArgs();

$xauthCookie = _xauthCookie();

EBox::init();

if ($usesX) {
    zenityPrecondition();
}

_xauthEBox($xauthCookie);

my $metadata;
try {
    clearTmpDir();
    createTmpDir();
    modPreConditions();
    setSystemDate();

    my $basicInfo = getUserAndPasswordAndServers($user, $password);
    my $credentials;
    my $date;

    while (not $date) {
        $credentials = getCredentials($basicInfo->{user},
                                      $basicInfo->{password},
                                      $basicInfo->{servers},
                                      $serverCN,
                                     );

        # Restore last backup for basic users always
        $restoreLast = ($restoreLast or ($credentials->{type} eq 'basic'));

        $date = askBackupDate($credentials, $restoreLast);

        if (not $date) {
            my $msg = __('No backups found in this server. Do you want to retry with a different one?');
            my $retry = $usesX ? _zenityQuestion($msg) : terminalQuestion($msg);
            if (not $retry) {
                exit 0;
            }
            next; # start again, retry
        }

        unless ( $credentials->{type} eq 'basic' ) {
            _downloadBackupMetadata($credentials, $date);
            $metadata = metadata($date);

            unless ( $metadata->{hasConfiguration} ) {
                my $msg = __('There is not configuration backup from this date. '
                             . 'Do you want to retry with another date?');
                my $retry = $usesX ? _zenityQuestion($msg) : terminalQuestion($msg);
                if (not $retry) {
                    exit(0);
                }
                undef($date);
                next; # Start all over again, retry
            }

            getEncryption(
                $credentials,
                $metadata,
                symmetricPassword => $symmetricPassword,
                encryptionKey     => $encryptKey,
                keyPassphrase     => $keyPassphrase,
                noEncryption      => $noEncryption,
               );
        }
    }

    my $toRestore = getBackupDomainsToRestore($credentials,
                                              $metadata,
                                              \@toRestoreCli);

    # Stop any interrupting process
    _stopInterruptingProcesses();

    _downloadBackupData($credentials, $date);

    my $configBackup = _getConfigBackup($credentials, $date);

    _installMissingModules($configBackup);



    doRestore(credentials => $credentials,
              toRestore   => $toRestore,
              configBackup => $configBackup,
              date         => $date);

    saveChanges();

    regenerateCaches();

    finishedMessage($credentials);
    clearTmpDir(); # Comment this for debug purposes
} otherwise {
    my $ex = shift @_;
    fatal($ex);
    $error = 1;
} finally {
    EBox::Global->deleteFirst();
};

exit $error;

sub parseArgs
{
    my $correct = GetOptions(
            'usage|help' => \$usage,
            'user|username=s' => \$user,
            'password=s' => \$password,
            'server-cn=s'   => \$serverCN,
            'backup-domain=s' => \@toRestoreCli,
            'x|gui!' => \$usesX,
            'last-date!' => \$restoreLast,
            'symmetric-password=s' => \$symmetricPassword,
            # TODO: Uncomment to enable gpg decrypt
            #'encryption-key=s'  => \$encryptKey,
            #'key-passphrase=s'   => \$keyPassphrase,
            'no-encryption+'     => \$noEncryption,
            );

    if ($usage or (not $correct)) {
        usage();
    }

    my $cryptOptions = grep { $_ } ($encryptKey, $symmetricPassword, $noEncryption);
    if ($cryptOptions > 1) {
        die __x('You can only specify one of the encryption options: {sy}, {no}',
                sy  => '--symmetric-password',
                no  => '--no-encryption');
    }

    if ($noEncryption) {
        $symmetricPassword = 0;
        $encryptKey = 0;
        $keyPassphrase = 0;
    }
}

sub zenityPrecondition
{
    system 'which zenity 1> /dev/null';
    if ($? != 0) {
        print __('Zenity package not found. Falling back to terminal mode') . "\n";
        $usesX = 0;
    }
}

sub usage
{
    print "restore-tool  [--user=username] [--password=password] [--server=serverCommonName] [--last-date]\n";
    print "              [--backup-domain=domain1] [--backup-domain=domain2]  ... \n";
    print "              [--no-encryption|--symmetric-password=PASSWORD]\n";
    print "              [--no-x]\n";
    print "\n";
    print "\t --user=USERNAME        \t ";
    print __("User for the authentication") . "\n";
    print "\t --password=PASSWORD    \t ";
    print __('Password for the authentication. This password will be shown both '
             . 'in the command line and in the process list so only use this option '
             . 'when security is not a concern') . "\n";
    print "\t --server=SERVER        \t ";
    print __("Server from which its backup date the restore will be done") . "\n";
    print "\t --last-date            \t ";
    print __("Use the last backup done for the restore")  . "\n";
    print "\t --backup-domain=DOMAIN \t ";
    print __("Backup domain to restore. It could be repeated several times") . "\n";
    print "\t--no-encryption|--symmetric-password=PASSWORD\n";
    print __('Check if we use the no encryption or a symmetric encryption with password '), "\n";
    print "\t --no-x                 \t ";
    print __("Do not use graphical interface") . "\n";

    exit 0;
}

sub tmpDir
{
    return '/var/lib/zentyal/tmp/zentyal-restore';
}

sub filesTmpDir
{
    return tmpDir() . '/files';
}

sub metaTmpDir
{
    return tmpDir() . '/meta';
}

sub modPreConditions
{
    my @mods = ('ebackup', 'remoteservices'); # add software when used
    foreach my $modName (@mods) {
        unless (EBox::Global->modExists($modName)) {
            fatal(__x('Module {mod} should be installed', mod => $modName));
        }

        my $mod = EBox::Global->modInstance($modName);
        if ($mod->isa('EBox::Module::Service')) {
            unless ($mod->configured()) {
                fatal(__x('Module {mod} should be configured', mod => $modName));
            }
        }
    }
}

sub setSystemDate
{
    my $cmd = 'ntpdate ' . NTP_SERVER;
    try {
        EBox::Sudo::root($cmd);
    } otherwise {
        warning(__('Could not automatically update system hour. Some restoration operations could fail if the date is not correct'));
    };
}

sub askServerCN
{
    my ($servers) = @_;
    my $serverCN;
    if ($usesX) {
        my @serversOrdered = sort @{ $servers  };
        $serverCN = _zenityList(__('Choose the server to restore'),
                                __('Server'),
                                  0, \@serversOrdered);
    } else {
        showServerList($servers);
        $serverCN = terminalPrompt(__("Server to restore: "));
    }

    _checkServerCN($serverCN, $servers);

    return $serverCN;
}

sub askDomainsToRestore
{
    my ($credentials, $metadata) = @_;

    my %availableDomains = %{ _backupDomainsAvailableByPrintableName($metadata) };

    my @domains;
    if ($usesX) {
        my @elements;
        while (my ($printableName, $name) = each %availableDomains) {
            if ($name eq 'filesIncludes') {
                push @elements, {
                                 item => $printableName,
                                 enabled => 0,
                                }
            } else {
                push @elements, $printableName;
            }
        }

        my $answer = _zenityList(__('Select backup domains to restore'),
                                 __('Backup domain'),
                                 1,
                                 \@elements,
                                 enabledByDefault => 1,
                                );
        @domains = @{ $answer };
    } else {
        my @availablePrintableNames = keys %availableDomains;
        my $printableList = join ', ', @availablePrintableNames;
        print __x('Backup domains available in the server {cn}: {l}',
                  cn => $credentials->{commonName},
                  l => $printableList);
        print "\n";
        my $unparsed = terminalPrompt("Backup domains to restore (comma separated): ");
        @domains =  split ',', $unparsed;
        foreach  (@domains) {
            $_ =~ s/^\s+//;
            $_ =~ s/\s+$//;
        }
    }

    # get domain name form printable name
    @domains = map {
        exists $availableDomains{$_} ? $availableDomains{$_} : ()
    } @domains;

    if (not @domains) {
        fatal(__('No backup domain selected to restore. Doing nothing'));
    }

    my %toRestore = map { $_ => 1 } @domains;

    return \%toRestore;
}

sub serverList
{
    my ($remoteServices, $user, $password)  = @_;

    my $msg = __('Retrieving registered servers list');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    my $list;
    try {
        $list = $remoteServices->serverList(user => $user,
                                            password => $password);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    return $list;
}


sub _setupPasswords
{
    my ($credentials) = @_;

    my $encKey = '';
    my $symPasswd = '';
    if (exists $credentials->{encValue} and
         ($credentials->{encValue} ne 'disabled')) {
        if (exists $credentials->{encSelected}) {
            my $selected = $credentials->{encSelected};
            my $value    = $credentials->{encValue};
            if ($selected eq 'asymmetric') {
                $encKey = $value;
            } elsif ($selected eq 'symmetric') {
                $symPasswd = $value;
            }
        }
    }

    if ($symPasswd) {
        EBox::EBackup::Password::setSymmetricPassword($symPasswd, 1);
    }

    if ($encKey) {
        if (not $credentials->{keyPassphrase}) {
            fatal(__('No key passphrase'));
        }
        EBox::EBackup::Password::setGpgPassphrase($credentials->{keyPassphrase}, 1);
    }

    my $password = $credentials->{password};
    if (not defined $password) {
        fatal(__('No password in retrieved credentials'));
    }
    EBox::EBackup::Password::setPasswdFile($password, 1);
}


sub backupCredentials
{
    my %params = @_;
    my $remoteServices = delete $params{remoteServices};
    my $credentials;

    my $msg = __('Retrieving account information');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        $credentials =
            $remoteServices->backupCredentials(
                    username   => $params{username},
                    password   => $params{password},
                    commonName => $params{serverCN},
                    force      => 1,
                    );
    } catch EBox::Exceptions::DataNotFound with  {
        $credentials = undef;
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    if (not defined $credentials) {
        $credentials = {
            username => $params{username},
            password => $params{password},
            method   => 'scp',
            type     => 'basic',
        };
    } else {
        $credentials->{type} = 'subscribed';
    }

    $credentials->{commonName} = $params{serverCN};

    if (not exists $credentials->{method}) {
        $credentials->{method} = 'scp';
    }

    return $credentials;
}


sub addEncryptionToCredentials
{
    my ($credentials, %params) = @_;

    if ($credentials->{type} ne 'subscribed') {
        return $credentials;
    }

    if ($params{symmetricPassword}) {
        $credentials->{encSelected} = 'symmetric';
        $credentials->{encValue} = $params{symmetricPassword};
    } elsif ($params{encryptionKey}) {
        $credentials->{encSelected} = 'asymmetric';
        $credentials->{encValue} = $params{encryptionKey};
        $credentials->{keyPassphrase} = $params{keyPassphrase};
    } else {
        $credentials->{encSelected} = 'none';
        $credentials->{encValue} = 'disabled';
    }

    return $credentials;
}


sub showServerList
{
    my ($serverList) = @_;

    if (not @{ $serverList }) {
        fatal(__("No registered Zentyal Servers"));
    }

    my @ordered = sort @{ $serverList};

    print "\n";
    print __('Registered Zentyal Servers');
    print "\n--------------------------------------\n";
    foreach my $server (@ordered) {
        print $server, "\n";
    }

    print "\n";
}

sub doRestore
{
    my %params = @_;

    my $configBackup = $params{configBackup};
    my $credentials = $params{credentials};
    my $date        = $params{date};
    my %toRestore = %{ $params{toRestore} };

    my $restoreConfig = delete $toRestore{configuration};
    if ($restoreConfig) {
        restoreConfig($configBackup);

        if ( $credentials->{type} ne 'basic' ) {
            _installCloudPackages($configBackup); # install cloud packages need
                                                  # access to special repositories
                                                  # granted by remoteservices
        }
    }

    if ($credentials->{type} eq 'basic') {
        # basic subscriptions backups only store the configuration, so we have
        # finished
        return;
    }

    my $ebackup = EBox::Global->modInstance('ebackup');

    my $urlParams   = _remoteUrlParamsFromCredentials($credentials, 'data');
    if ($toRestore{filesIncludes}) {
        _restoreAllFiles($ebackup, $date);
    } else {
        _restoreBackupDomainsFiles($ebackup, $date, \%toRestore);
    }


    if ($toRestore{logs}) {
        _restoreLogs($date);
    }
}


# Restore the files whose source are backup domains
sub _restoreBackupDomainsFiles
{
    my ($ebackup, $date, $toRestore) = @_;

    my $msg = __('Restoring files');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        # restore backup domains

        foreach my $mod (@{ EBox::Global->modInstances() }) {
            $mod->can('backupDomainsFileSelection') or next;

            my $selection = $mod->backupDomainsFileSelection(%{ $toRestore } );
            if ((not defined $selection) or (keys %{ $selection} == 0)) {
                next;
            }

            foreach my $file (@{ $selection->{'includes'} }) {
                $file =~ s{/+$}{};
                my $srcFile = _fileFromBackup($file);
                my $dstFile = $file;

                try {
                    _restoreFile($srcFile, $dstFile);
                } otherwise {
                    my $ex = shift;
                    my $msg = __x('Cannot restore file {file} requested by backup domains. Reason: {reason}',
                                  file => $file,
                                  reason => "$ex",
                                 );
                    EBox::warn($msg);
                };
            }
        }
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _restoreAllFiles
{
    my ($ebackup, $date) = @_;
    my $srcDir = filesTmpDir();

    my $msg = __('Restoring all backed-up files');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    # regular files in / are not restored anyway they should be links to
    # /boot that should not be touched
    try {
        my %leftAloneDirs = (
                             '/boot' => 1,
                             '/proc' => 1,
                             '/dev' => 1,
                             '/sys' => 1,
                            );

        my @dirsInBackup = @{ EBox::Sudo::root("find $srcDir -type d -maxdepth 1") };
        foreach my $dir (@dirsInBackup) {
            chomp $dir;
            my $toRestore = $dir;
            if ($toRestore eq $srcDir) {
                next;
            }

            $toRestore =~ s{^/*$srcDir}{};

            if (exists $leftAloneDirs{$toRestore} and $leftAloneDirs{$toRestore}) {
                next;
            }

            _restoreFile($dir, $toRestore);
        }

        # remove extra data directory
        my $extraDataDir = $ebackup->extraDataDir();
        EBox::Sudo::root("rm -rf $extraDataDir");
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _restoreFile
{
    my ($src, $dst) = @_;

    # my $tmpDst;

    my $srcArg = $src;
    if (EBox::Sudo::fileTest('-e', $dst)) {
        if (EBox::Sudo::fileTest('-d' , $dst)) {
            if (not EBox::Sudo::fileTest('-d', $src)) {
                error(__x('Could no restore {dst}, it already exists nad it is not a directory',
                      dst => $dst));
                next;
            }

            $srcArg = "$src/*";
            my $srcEmpty;
            try {
                EBox::Sudo::root("ls $srcArg");
            } otherwise {
                $srcEmpty = 1;
            };
            if ($srcEmpty) {
                # no files to copy to laready existent directory..
                next;
            }
        }
    }

    my $restoreCmd = "cp -rpf $srcArg $dst";
    try {
        EBox::Sudo::root($restoreCmd);
    } otherwise {
        error(__x(
            'Error restoring file or directory {dst}',
            dst => $dst
           ));
    };
}

# sliced-mode is not supported
sub _restoreLogs
{
    my ($date) = @_;

    my $dir = _fileFromBackup( EBox::EBackup::DBRestore::backupDir());
    my $dumpFile =  $dir . '/' . EBox::EBackup::DBRestore::dumpBasename() . '.dump';

    if (not  EBox::Sudo::fileTest('-r', $dumpFile) ) {
        warning(__('Backup log data not found, log database will not be restored'));
        return;
    }

    my $msg = __('Restoring log database');
    my $pulsatePid = _showUnanticipatedProgress($msg);
    try {
        EBox::EBackup::DBRestore::restoreEBoxLogsFromDir($dir, $date);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub restoreConfig
{
    my ($configBackup) = @_;

    preRestoreConfigChecks($configBackup);

    my $progressIndicator =
        EBox::Backup->prepareRestoreBackup($configBackup,
                                           revokeAllOnModuleFail => 0,
                                           continueOnModuleFail  => 1
                                          );

    my $retValue = progress($progressIndicator, __('Restoring configuration backup'));
    if ($retValue != 0) {
        my $errorMsg = $progressIndicator->errorMsg();
        if ($errorMsg) {
            my $msg = $errorMsg . "\n";
            $msg .= __('The configuration restore failed. We will continue the process to try to restore as much as possible but your system will need manual tweaking');
            error($msg);
            return;
        } else {
            EBox::warn("Progress indicator for restoreConfig does not specify any error but has returned the following value: $retValue.");
        }
    }

    postRestoreConfigMangling();
}

sub preRestoreConfigChecks
{
    my ($configBackup) = @_;

    my $msg = __('Checking configuration compability');
    my $unanticipatedProgress = _showUnanticipatedProgress($msg);

    # check that interfaces referenced in network exist
    # XXX try to mangle this if possible to allow restore
    my $dir;
    try {
        $dir = EBox::Backup->_unpackAndVerify($configBackup);
        EBox::Backup->_unpackModulesRestoreData($dir);

        _preRestoreNetworkCheck($dir);
    } finally {
        system "rm -rf $dir";
        _finishUnanticipatedProgress($unanticipatedProgress);
    };
}


sub _preRestoreNetworkCheck
{
    my ($dir) = @_;

    my $confBakFile = "$dir/eboxbackup/network.bak/network.bak";
    if (not -r $confBakFile) {
        EBox::error("Cannot found data for network module, Skipping network pre-restore check");
        return;
    }

    my @enabledIfaces;

    # Open the config
    my @yaml = YAML::XS::LoadFile($confBakFile);
    foreach my $spec (@yaml) {
        my $iface;
        if ($spec->{key} =~ m{^/ebox/modules/network/interfaces/(.*?)/method$}) {
            $iface = $1;
        }  else {
            # not interested in this key
            next;
        }

        # no enabled, safe to ignore
        next if ($spec->{value} eq 'notset');

        push @enabledIfaces, $iface;
    }

    my @missing = grep {
        not EBox::NetWrappers::iface_exists($_)
    } @enabledIfaces;

    if (@missing) {
        my $msg = __x('Cannot restore backup because there are less interfaces than there are available. The missing interfaces are: {missing}',
                      missing => join ',', @missing
                     );
        fatal($msg);
    }
}

sub _installMissingModules
{
    my ($configBackup) = @_;

    my %modulesInBackup = map { $_ => 1 } @{ EBox::Backup->_modulesInBackup($configBackup) };
    my %modulesToConfigure  = %modulesInBackup;

    foreach my $modName ( @{ EBox::Global->modNames() }) {
        delete $modulesInBackup{$modName};
        my $mod = EBox::Global->modInstance($modName);
        if ((not $mod->isa('EBox::Module::Service')) or
             $mod->configured()) {
            delete $modulesToConfigure{$modName};
        }
    }

    my @missingModules = keys %modulesInBackup;
    if (@missingModules) {
        _updateDebPackagesList();
        EBox::info("Missing modules to recover the configuration: @missingModules");
        _installDebPackages(@missingModules);
    }

    my @unconfModules = keys %modulesToConfigure;
    if (@unconfModules) {
        EBox::info("Modules to configure: @unconfModules");
        _configureModules(@unconfModules);
    }
}


sub _updateDebPackagesList
{
    my ($msg) = @_;

    if (not $msg) {
        $msg = __('Updating software package lists');
    }

    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        EBox::Sudo::root('apt-get update -q');
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _installDebPackages
{
    my @modules = @_;

    my @packages;
    foreach my $mod (@modules) {
        next if EBox::Global->modExists($mod);

        # cloud-prof is a special case
        next if ($mod eq 'cloud-prof');

        push (@packages, "zentyal-$mod");
    }

    if (@packages) {
        my $msg = __('Installing Zentyal components and their dependencies');
        _aptInstall(\@packages, $msg);
    }

    # TODO: assure that modules are loaded and retrievable by EBox::Global->modInstance
}

sub _aptInstall
{
    my ($packages_r, $msg) = @_;

    my @packages = @{ $packages_r };

    my $software = EBox::Global->modInstance('software');
    my $progressIndicator = $software->installPkgs(@packages);
    my $retValue = progress($progressIndicator,
                         __('Installing missing modules...'));
    if ($retValue != 0) {
        my $errorMsg = $progressIndicator->errorMsg();
        my $msg;

        if ($errorMsg) {
            my $msg = __x('Error installing packages: {err}. You can continue but you would not restore any data for the missing packages',
                          err => "\n$errorMsg\n");
            error($msg);
            return;
        } else {
            EBox::warn("Progress indicator for _aptInstall does not specify any error but has returned the following value: $retValue.");
        }
    }
}

sub _installCloudPackages
{
    my ($confBackup) = @_;

    my $remoteservices = EBox::Global->modInstance('remoteservices');
    unless ($remoteservices->eBoxSubscribed()) {
        return;
    }

    my $openvpn = EBox::Global->modInstance('openvpn');
    my $loaded = _loadSubscriptionBundle($remoteservices, $openvpn);
    unless ($loaded) {
        # could not install this packages without bundle
        return;
    }

    my @toInstall;

    my %cloudPackages = (
                         'ebox-cloud-prof',
                         'zentyal-security-updates',
                        );

    my $installedPackages = _debPackagesInBackup($confBackup);
    foreach my $package (@{ $installedPackages }) {
        if (exists $cloudPackages{$package}) {
            push @toInstall, $package;
            delete $cloudPackages{$package};
            if (keys %cloudPackages == 0) {
                last;
            }
        }
    }

    unless (@toInstall) {
        return;
    }

    _updateDebPackagesList(__('Updating package list to allow access to exclusive Zentyal Cloud packages'));

    my $msg = __('Install cloud packages');
    _aptInstall(\@toInstall, $msg);

    # No configure modules stage required because:
    # ebox-cloud-prof no needs configuration but only restoring
    # zentyal-security-updates is not a zentyal module
    my $cloudProfInstalled = grep { $_ eq 'cloud-prof'  } @toInstall;
    if ($cloudProfInstalled) {
        EBox::Backup->restoreBackup($confBackup, revokeAllOnModuleFail => 0,
                                    modsToRestore => [ 'cloud-prof' ]);
    }
}


sub _loadSubscriptionBundle
{
    my ($remoteservices, $openvpn) = @_;

    my $msg = __('Downloading subscription data');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    my $res;
    try {
        $openvpn->restartService();
        $remoteservices->restartService(); # to assure connection
        $res = $remoteservices->reloadBundle('force');
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    if ($res == 1) {
        # success!
        return 1;
    }

    if ($res == 0) {
        warning(__('Connection error when retrieving subscription bundle. Zentyal Cloud exclusive packages will not be installed'));

    } elsif ($res == 2) {
        warning(__('Cannot retrieve bundle because either installed ' .
                   'zentyal-remoteservices is outdated or only outdated ' .
                   'bundle is available in the cloud. Zentyal Cloud  ' .
                   'exclusive packages will not be installed'));
    } else {
        warning(__('Unknown error retrieving subscription bundle. Zentyal Cloud exclusive packages will not be installed'));
    }

    return 0;
}

sub _debPackagesInBackup
{
    my ($confBackup) = @_;

    my @packages;
    my $tmpDir = EBox::Backup->_unpackArchive($confBackup, 'debpackages');
    try {
        my $file = "$tmpDir/eboxbackup/debpackages";
        open (my $FH, "<", $file) or
            die "Error opening installed packages file $!";
        while (my $line = <$FH>) {
            # lines ae like: ii apache2.2-common 2.2.14-1 Apache HTTP Server
            if ($line =~ m/\Aii\s+(.*?)\s/) {
                push @packages, $1;
            }
        }
        close $FH or
            die "Error closing isntalled packages file: $!";
    } finally {
        system "rm -rf $tmpDir";
    };

    return \@packages;
}


sub _configureModules
{
    my @modulesToConfigure = @_;

    unless (@modulesToConfigure) {
        return;
    }

    my %toConfigure = map { $_ => 1 } @modulesToConfigure;

    my $mgr = EBox::ServiceManager->new();
    my @orderedMods = @{$mgr->_dependencyTree()};

    my $PROGRESS_BAR;
    $usesX and
      local $SIG{PIPE} = 'IGNORE';

    my $pid;
    if ($usesX) {
        my $msg = __('Configuring modules');
        my $cmd = _zenityProgress($msg);
        $pid = open($PROGRESS_BAR, "|-");
        if ( $pid == 0 ) {
            # Child code
            exec { $cmd->[0] } @{$cmd};
            exit(2);
        }
    } else {
        print "\n";
    }

    my $i = 0;
    my $percent;
    foreach my $name (@orderedMods) {
        $i += 1;
        next unless (exists $toConfigure{$name});

        my $percent = ($i/(scalar @orderedMods)) * 100;
        $percent = sprintf("%i", $percent);

        if ($PROGRESS_BAR) {
            print $PROGRESS_BAR $percent . "\n" or
                _zenityProgressFail($!, $?);
            print $PROGRESS_BAR '#' . __x('Configuring modules: Current module {mod}', mod => $name) . "\n"
              or _zenityProgressFail($!, $?);
        } elsif (not $usesX) {
            print "\r";
            my $msg =  __x('Configuring modules {p} done. Current module {mod}',
                           p => "$percent%", mod => $name);
            print $msg;
            print "\n";
        }

        print "About to configure $name\n"; # DDDD
        my $module = EBox::Global->modInstance($name);
        $module->setInstalled();
        $module->setConfigured(1);
        $mgr->updateModuleDigests($name);

        try {
            $module->enableActions();
        } otherwise {
            my ($ex) = @_;
            my $err = $ex->text();
            $module->setConfigured(0);
            $module->enableService(0);
            my $msg = __x('Failed to configure module {name}: {err}. This could affect to the restore from other modules',
                          name => $module->name(),
                          err  => $err,
                         );
            warning($msg);
        };

        $mgr->updateModuleDigests($name); # in ConfigureModuleController this is
            # call bef and after the enableActions
        print "Finished configuring $name\n"; # DDDD
    }

    if ($PROGRESS_BAR) {
        print $PROGRESS_BAR "100\n" or
            _zenityProgressFail($!, $?);
        close $PROGRESS_BAR or
            _zenityProgressFail($!, $?);

        if ($pid) {
            waitpid($pid, 0);
        }
    }

    my $saveChangesMsg = __('Finishing new modules configuration');
    print "Saving changes for new modules\n"; # DDD
    saveChanges($saveChangesMsg);
}


sub postRestoreConfigMangling
{
     # XXX here we will fix config items

}

# Stop any interrupting processes if required
sub _stopInterruptingProcesses
{
    try {
        my $gl = EBox::Global->getInstance();
        if ( $gl->modExists('events') ) {
            my $evts = $gl->modInstance('events');
            $evts->stopService();
        }
    } otherwise { };
}

sub _downloadBackupMetadata
{
    my ($credentials, $date) = @_;
    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        return;
    }

    my $dstDir = metaTmpDir() ;
    if (not -d $dstDir) {
        mkdir $dstDir;
    }

    my $msg = __('Downloading backup metadata...');

    my $pulsatePid = _showUnanticipatedProgress($msg);
    try {
        EBox::EBackup::Subscribed::downloadDRMetadata($credentials, $date, $dstDir);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _downloadBackupData
{
    my ($credentials, $date) = @_;
    my $basic = $credentials->{type} eq 'basic';
    if ($basic) {
        return;
    }

    my $dstDir = filesTmpDir();
    my $msg = __('Downloading the backup data and configuration');
    my $urlParams = _remoteUrlParamsFromCredentials($credentials, 'data');

    _downloadDuplicityFiles($urlParams, $date, $dstDir, $msg);
}

sub _downloadDuplicityFiles
{
    my ($urlParams, $date, $dstDir, $msg) = @_;

    my $pulsatePid = _showUnanticipatedProgress($msg);
    try {
        my $ebackup = EBox::Global->modInstance('ebackup');

        # restore all files, this is done to sepepd-up the process
        $ebackup->restoreFile('/', $date, $dstDir, $urlParams);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _fileFromBackup
{
    my ($file) = @_;
    return filesTmpDir() . '/' . $file;
}

sub _getConfigBackup
{
    my ($credentials, $date) = @_;

    my $basic = $credentials->{type} eq 'basic';

    if (not $basic) {
        my $ebackup = EBox::Global->modInstance('ebackup');
        my $backupFile =  $ebackup->includedConfigBackupPath();
        return _fileFromBackup($backupFile);
    }

    my $dstFile = tmpDir() . '/backup-config';
    my $msg =  __('Downloading configuration');;
    my $pulsatePid = _showUnanticipatedProgress($msg);
    try {
        _downloadBasicConfigurationBackup($credentials, $date, $dstFile);
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    return $dstFile;
}

sub askBackupDate
{
    my ($credentials, $restoreLast) = @_;

    if ($credentials->{type} eq 'basic') {
        return _basicBackupDate($credentials, $restoreLast);
    }

    # extractions of date coudl take a logn time, maybe we can put a progress
    # widget there
    my $commonName = $credentials->{commonName};
    my $ebackup = EBox::Global->modInstance('ebackup');

    my $msg = __('Retrieving backup collection status ...');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    my @dates;
    my $lastDate;
    my $fail = 0;
    try {
        my $urlParams = _remoteUrlParamsFromCredentials($credentials, 'data');
        if ($restoreLast) {
            $lastDate= $ebackup->lastBackupDate($urlParams);
        } else {
            my $status = $ebackup->remoteStatus($urlParams);
            my %times = map { str2time($_->{date}) => $_->{date} } @{$status};
            my @sortDates = sort { $b <=> $a } keys(%times);
            @dates = map { $times{$_}; } @sortDates;
        }
    } otherwise {
        my $ex = shift;
        warning($ex);
        $fail = 1;
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };

    if ($fail) {
        return undef;
    }

    if ($lastDate) {
        print __x('Last backup date was: {date}', date => $lastDate) . "\n";
        return $lastDate;
    }

    if (not @dates) {
        # fatal(__x(
        #           'No backups found for server {server}',
        #           server => $credentials->{commonName}
        #          )
        #      );
        return undef;
    }

    return _backupDateInput($commonName, \@dates);
}

sub _basicBackupDate
{
    my ($credentials, $restoreLast) = @_;
    my $remoteBackup = EBox::RemoteServices::ProxyBackup->new(
                                          user => $credentials->{username},
                                          password => $credentials->{password},
                                                             );
    my $commonName = $credentials->{commonName};
    my $allBackups = $remoteBackup->listRemoteBackups();
    if (not exists $allBackups->{$commonName}) {
        warning(__x('No automatic configuration backups were made for the server {s}',
                  s => $commonName
                 )
            );
    }

    my $backups = $allBackups->{$commonName};
    if ($restoreLast) {
        return _lastBasicBackupDate($backups);
    }

    my @dates = map {
        $_->{Date}
    } values %{ $backups };

    return _backupDateInput($commonName, \@dates);
}


sub _lastBasicBackupDate
{
    my ($backups) = @_;

    my $lastDate;
    my $lastDateStr;
    while (my ($name, $attrs) = each %{ $backups }) {
        my ($dateStr) = split '\+', $attrs->{Date};
        my $date = DateTime->from_epoch(epoch => str2time($dateStr));

        if ((not defined $lastDate) or ($date > $lastDate)) {
            $lastDate = $date;
            $lastDateStr = $attrs->{Date};
        }
    }

    print __x('Last backup date was: {date}', date => $lastDateStr) . "\n";
    return $lastDateStr;
}

sub _backupDateInput
{
    my ($commonName, $dates) = @_;
    my $chosen;
    if ($usesX) {
        # first date in the list enabled
        my $firstDate = $dates->[0];
        $dates->[0] = {
            item => $firstDate,
            enabled => 1,
        };

        $chosen = _zenityList(__x('Choose date to restore the backup from server {cn}',
                                  cn => $commonName
                                 ),
                                __('Date'),
                                  0, $dates);
    } else {
        $chosen = _terminalDateInput($commonName, $dates);
    }

    return $chosen;
}


sub _downloadBasicConfigurationBackup
{
    my ($credentials, $date, $dstFile) = @_;
    my $remoteBackup = EBox::RemoteServices::ProxyBackup->new(
                                          user => $credentials->{username},
                                          password => $credentials->{password},
                                                             );
    my $commonName = $credentials->{commonName};
    my $allBackups = $remoteBackup->listRemoteBackups();
    if (not exists $allBackups->{$commonName}) {
        fatal(__x(
              'No automatic configuration backups were done for the server {s}',
                  s => $commonName,
                )
             );
    }

    my $backups = $allBackups->{$commonName};

    my $chosen;
    while (my ($name, $attrs) = each %{ $backups }) {
        if ($attrs->{Date} eq $date) {
            $chosen = $name;
            last;
        }
    }

    unless (defined $chosen) {
        fatal(__x('No configuration backups were made for the date {d} in {s} server',
              s => $commonName, d => $date));
    }

    my $tmpFile = $remoteBackup->downloadRemoteBackup($commonName, $chosen);
    EBox::Sudo::command("mv -f '$tmpFile' '$dstFile'");
    return $dstFile;
}

sub clearTmpDir
{
    my $tmpDir = tmpDir();

    EBox::Sudo::silentRoot("rm -rf $tmpDir");
}

sub createTmpDir
{
    my $tmpDir = tmpDir();
    unless ( -d $tmpDir ) {
        mkdir($tmpDir);
    }
}


sub _checkServerCN
{
    my ($serverCN, $servers) = @_;

    my $serverFound = grep { $serverCN eq $_ } @{ $servers };

    unless ($serverFound) {
        fatal(__x('The server {server} is not registered in Zentyal Cloud',
                  server => $serverCN));
    }
}


sub _getDomainsInBackup
{
    my ($ebackup, $credentials, $date) = @_;

    my $listPath = _fileFromBackup($ebackup->enabledDomainsListPath());
    if (not -f $listPath) {
        EBox::warn('No backup domain lists, assuming all were backed-up');
        return undef;
    }

    my @domains = split ',', File::Slurp::read_file($listPath);

    my $domainsHash = { map { $_ => 1 } @domains };

    return $domainsHash;
}

sub _backupDomainsAvailableByPrintableName
{
    my ($metadata) = @_;

    my %domains;
    while(my ($key, $data) = each %{$metadata->{backupDomains}}) {
        # ignore failed backups
        if ($data->{failed}) {
            next;
        }
        $domains{$data->{printableName}} = $key;
    }

    return \%domains;
}

sub terminalPrompt
{
    my ($msg, $hide) = @_;

    if ($hide) {
        ReadMode('noecho');
    }

    my $input = undef;
    while (not defined $input) {
        print  $msg;
        $input = readline(*STDIN);
        print "\n";

        chomp $input;
        $input =~ s/^\s+//;
        $input =~ s/\s+$//;

        if ($input eq '') {
            $input = undef;
            print __('Please, enter a value');
            print "\n";
        }
    }

    if ($hide) {
        ReadMode('normal');
    }

    return $input;
}


sub terminalQuestion
{
    my ($msg) = @_;
    $msg .= '(y/n):';
    my $answer;
    while (not $answer) {
        $answer = terminalPrompt($msg);
        if (($answer eq 'yes') or ($answer eq 'y')) {
            return 1;
        } elsif (($answer eq 'no') or $answer eq 'n') {
            return 0;
        } else {
            print __('Please answer yes or no') , "\n";
            $answer = undef;
        }
    }
}

sub _terminalProgressIndicator
{
    my ($progressIndicator, $msg) = @_;
    my $percent = 0;
    print "\n";
    while ($percent < 100) {
        print "\r$msg: $percent%";
        $percent = $progressIndicator->percentage();
        sleep 1;
    }
    print "\r$msg: $percent%\n";

    return $progressIndicator->retValue();
}


sub _terminalDateInput
{
    my ($commonName, $dates) = @_;

    print __x('Backup dates for server {cn}', cn => $commonName);
    print "\n------------------------------------------\n";
    foreach my $date (@{ $dates }) {
        print "$date\n";
    }

    my %validDates= map { $_ => 1 } @{ $dates };

    my $selected = undef;
    while (not defined $selected) {
        print "\n";
        $selected = terminalPrompt(__('Enter backup date to restore:'));

        unless (exists $validDates{$selected}) {
             print __x('Invalid date: {d}. Try again', d => $selected);
             print "\n";
             $selected = undef;
         }
    }

    return $selected;
}

sub _zenityQuote
{
    my ($text) = @_;

    $text = shell_quote($text);

    if ($text =~ m/a href/) {
        # GTK needs these changes in URLs
        # escape ampersand
        $text =~ s/&/&amp;/g;
        # remove target attr
        $text =~ s/target=".*?"//g;
    }

    return $text;
}

sub _zenityCommonArgs
{
    my ($width) = @_;
    defined ($width) or $width = 300;

    if ( wantarray ) {
        my @args = "--width=$width";
        push(@args, '--title=' . _zenityTitle(1));
        push(@args, _zenityIcon());
        return @args;
    } else {
        my $args = "--width=$width --title " . _zenityTitle() . ' ';
        $args .= _zenityIcon() . ' ';
        return $args;
    }
}

sub _zenityTitle
{
    my ($notQuote) = @_;
    if ( $notQuote ) {
        return 'Zentyal Disaster Recovery';
    } else {
        return _zenityQuote('Zentyal Disaster Recovery');
    }
}

sub _zenityIcon
{
    my $path = EBox::Config::www() . 'favicon.ico';
    if (-r $path) {
        return "--window-icon=$path";
    }

    return '';
}

# Type: info | warning | error
#
sub _zenityMessage
{
    my ($type, $text) = @_;

    my $commonArgs = _zenityCommonArgs();
    $text = _zenityQuote($text);
    my $cmd = qq{zenity --$type $commonArgs --text=$text};

    EBox::Sudo::command($cmd);
}

sub _zenityEntry
{
    my ($text, $hide) = @_;

    $text = _zenityQuote($text);
    my $commonArgs = _zenityCommonArgs();
    my $cmd = qq{zenity --entry $commonArgs --text=$text};
    if ($hide) {
        $cmd .= ' --hide-text';
    }

    my $answer = undef;
    while (not defined $answer) {
        try {
            my $output = EBox::Sudo::command($cmd);
            $answer = _zenityAnswerFromOutput($output);
            if ($answer eq '') {
                $answer = undef;
            }
        } catch EBox::Exceptions::Command with {
            my $ex = shift;
            if ($ex->exitValue() == 1) {
                # cancel button pressed
                _zenityUserAbort();
            } else {
                $ex->throw();
            }
        };

        unless (defined $answer) {
            _zenityMessage('warning', __('This entry is mandatory to continue the restoring process. Retry'));
        }
    }

    return $answer;
}

sub _zenityQuestion
{
    my ($text) = @_;

    $text = _zenityQuote($text);
    my $commonArgs = _zenityCommonArgs();
    my $cmd = qq{zenity --question $commonArgs --text=$text};

    my $ret;
    try {
        EBox::Sudo::command($cmd);
        $ret = 1;
    } catch EBox::Exceptions::Command with {
        my $ex = shift;
        if ($ex->exitValue() == 1) {
            # exit code signals 'no' answer
            $ret = 0;
        } else {
            # exit code signals error in application
            $ex->throw();
        }
    };

    return $ret;
}

sub _zenityList
{
    my ($text, $column, $multiple, $list, %params) = @_;
    $text = _zenityQuote($text);
    my $enabledByDefault = $params{enabledByDefault};

    my $commonArgs = _zenityCommonArgs();

    my $cmd = qq{zenity --height 250 --list $commonArgs --text=$text };
    if ($multiple) {
        $cmd .=  "--checklist";
    } else {
        $cmd .= " --radiolist";
    }

    $cmd .=  q{ --column } . __('Selection') . qq{ --column "$column" };

    foreach my $element (@{ $list}) {
        my $enabled = $enabledByDefault;

        my $item;
        if (ref $element eq 'HASH') {
            $item = $element->{item};
            $enabled = $element->{enabled};
        } else {
            $item = $element;
        }

        if ($enabled) {
            $cmd .= qq{ TRUE "$item"};
        } else {
            $cmd .= qq{ FALSE "$item"};
        }
    }

    my $answer = undef;
    while (not defined $answer) {
        try {
            my $output = EBox::Sudo::command($cmd);
            $answer = _zenityAnswerFromOutput($output);
            if ($answer eq '') {
                $answer = undef;
            }
        } catch EBox::Exceptions::Command with {
            my $ex = shift;
            if ($ex->exitValue() == 1) {
                # cancel button pressed
                _zenityUserAbort();
            } else {
                $ex->throw();
            }
        };

        if (not defined $answer) {
            _zenityMessage('warning', __('This entry is mandatory to carry on the restoring process. Choose from the list'));
        }
    }

    if ($multiple) {
        my @answerList = split '\|', $answer;
        return \@answerList;
    }

    return $answer;
}


sub _zenityAnswerFromOutput
{
    my ($output) = @_;
    my $answer = $output->[0];
    defined $answer or
        return undef;

    chomp $answer;

    $answer =~ s/^\s*//;
    $answer =~ s/\s*$//;
    # Decoding UTF8 strings if any...
    utf8::decode($answer);
    return $answer;
}

sub _zenityProgress
{
    my ($text, $pulsate) = @_;

    my @commonArgs = _zenityCommonArgs($pulsate ? 300 : 400);

    my @args = ('--auto-close');
    if ($pulsate) {
        push(@args, '--pulsate');
    } else {
        push(@args, '--auto-kill');
    }

    my @cmd = ('zenity', '--progress');
    push(@cmd, @commonArgs);
    push(@cmd, @args);
    push(@cmd, "--text=$text");
    return \@cmd;
}

sub _zenityProgressIndicator
{
    my ($progressIndicator, $text) = @_;
    my $cmd = _zenityProgress($text);

    local $SIG{PIPE} = 'IGNORE';
    my $PR;
    my $pid = open ($PR, '|-');
    select ((select ($PR), $|=1)[0]); #autoflush
    if ( $pid == 0 ) {
        # Child code
        exec { $cmd->[0] } @{$cmd};
        exit(2);
    }
    my $percent = 0;
    while (not $progressIndicator->finished()) {
        $percent = $progressIndicator->percentage();
        if ($percent) {
            # Avoid progress bar premature finish:
            $percent = 99 if ($percent >= 100);

            print $PR "$percent\n" or
                _zenityProgressFail($!, $?);
        }
        my $message = $progressIndicator->message();
        if ($message) {
            # Avoid long lines that make the dialog ugly
            if ($message =~ /Downloading /) {
                my @tokens = split (' ', $message);
                $message = "$tokens[0] $tokens[3] ($tokens[4])\n";
            } elsif ($message =~ /Unpacking /) {
                $message =~ s/\(from .*\)\s//;
            }
            $message =~ s/^\s//;

            print $PR "#$text" . '\n' . "$message\n" or
                _zenityProgressFail($!, $?);
        }
        sleep 1;
    }

    close $PR or
        _zenityProgressFail($!, $?);

    if ($pid) {
        waitpid($pid, 0);
    }

    return $progressIndicator->retValue();
}

sub _zenityProgressFail
{
    my ($err, $exitValue) = @_;
    if ($err eq 'Broken pipe' and ($exitValue == 0)) {
        _zenityUserAbort();
    } elsif ($err eq 'Broken pipe') {
        # error closing progress bar. We ignore it
        return;
    } else {
        fatal("$err. Exit code: $exitValue");
    }
}


sub _showUnanticipatedProgress
{
    my ($msg) = @_;
    if ($usesX) {
        return _zenityPulsate($msg);
    } else {
        print $msg . "\n";
        print __('Please wait') . "\n";;
        return undef;
    }
}

sub _finishUnanticipatedProgress
{
    my ($pulsatePid) = @_;

    if ($usesX) {
        if (defined $pulsatePid) {
            _zenityPulsateClose($pulsatePid);
        }
    } else {
        print __('Finished') . "\n";
    }
}


sub _zenityPulsate
{
    my ($text) = @_;

    my $pid = fork();
    if ($pid) {
        # parent
        return $pid;
    }

    # child code
    chdir '/'               or die "Can't chdir to /: $!";
    open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null';

    die "Can't start a new session: $!" if setsid == -1;
    open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";

    my $zenityCmd = _zenityProgress($text, 1);
    $pid = open my $PROC, "|-";
    if ( $pid == 0 ) {
        # Child code
        exec { $zenityCmd->[0] } @{$zenityCmd};
        exit(2);
    }

    while (1) {
        print $PROC 1;
    }
    close $PROC;

    if ($pid) {
        waitpid($pid, 0);
    }

    exit(0);
}


sub _zenityPulsateClose
{
    my ($pulsatePid) = @_;
    # Send SIGABRT
    kill(6, $pulsatePid);

    # XXX use kill -9 if it does not close

    # To avoid zombie processes, this is a blocking operation
    if ($pulsatePid) {
        waitpid($pulsatePid, 0);
    }
}

sub _zenityUserAbort
{
    my $msg = __('Restoring process aborted upon user request');
    fatal($msg);
}


sub _remoteUrlParamsFromCredentials
{
    my ($credentials, $targetType) = @_;

    my $target = $credentials->{server} . '/' . $credentials->{commonName} ;
    $target .= "/$targetType";
    my %params = (
        method => $credentials->{method},
        user   => $credentials->{username},
        password => $credentials->{password},
        target => $target,
        encValue => $credentials->{encValue},
        encSelected => $credentials->{encSelected},
        alternativePassword => 1,
    );

    return \%params;
}

# Perform saving changes
sub saveChanges
{
    my ($msg, $retry) = @_;
    defined($msg) or $msg =  __('Saving configuration changes');
    defined($retry) or $retry = 1;

    my $global = EBox::Global->getInstance();
    my $progressIndicator = $global->prepareSaveAllModules();

    my $retValue = progress($progressIndicator, $msg);
    if ($retValue != 0) {
        my $errorMsg = $progressIndicator->errorMsg();
        if ($retry) {
            # first try, save changes failed, do a retry
            $errorMsg or $errorMsg = 'Unknown';
            EBox::warn("Error saving changes (will retry): $errorMsg");
            saveChanges($msg, 0);
        } else {
            if ($errorMsg) {
                my $msg = $errorMsg . "\n";
                $msg .= __('Error saving configuration changes; some Zentyal modules would remain in a unknown state');
                error($msg);
                return;
            } else {
                EBox::warn("Progress indicator for saveChanges does not specify any error but has returned the following value: $retValue.");
            }
        }
    }
}

# Regenerate the ebackup cache for file list that it is not done
# already for restarting the module so we have to do it by hand
sub regenerateCaches
{
    my $msg = __('Regenerating file list cache');
    my $pulsatePid = _showUnanticipatedProgress($msg);

    try {
        my $ebackup = EBox::Global->modInstance('ebackup');
        $ebackup->remoteGenerateListFile();
    }  catch EBox::Exceptions::NotConnected with {
        warning(
                __('Cannot connect to the Cloud to regenerate backup list. Please try again later.')
               );
    } finally {
        _finishUnanticipatedProgress($pulsatePid);
    };
}

sub _xauthCookie
{
    unless ($usesX) {
        return undef;
    }

    my $cmd = 'xauth list';
    my @output = `$cmd`;
    foreach my $line (@output) {
        chomp $line;
    }
    return \@output;
}

sub _xauthEBox
{
    my ($cookieList) = @_;

    unless($usesX) {
        return;
    }

    my $xauthFile = '/var/lib/zentyal/.Xauthority';
    EBox::Sudo::root("rm -f $xauthFile");
    EBox::Sudo::root("touch $xauthFile");
    EBox::Sudo::root("chown ebox.ebox $xauthFile");

    foreach my $cookie (@{ $cookieList }) {
        EBox::Sudo::command("xauth -f $xauthFile add $cookie");
    }
}

sub progress
{
    my ($progressIndicator, $msg)  = @_;

    if (not $progressIndicator->started()) {
        $progressIndicator->runExecutable();
    }

    if ($usesX) {
        return _zenityProgressIndicator($progressIndicator, $msg);
    } else {
        return _terminalProgressIndicator($progressIndicator, $msg);
    }
}

sub getUserAndPasswordAndServers
{
    my ($user, $password) = @_;

    my $remoteServices = EBox::Global->modInstance('remoteservices');
    my $servers;

    while (not ($user and $password)) {
        if (not $user) {
            $user = input(__('Zentyal Cloud User'));
        }
        if (not $password) {
            $password = password(__('Zentyal Cloud Password'));
        }

        try {
            $servers = serverList($remoteServices, $user, $password);
        } otherwise {
            my $ex = shift;
            showException($ex);
            $user = $password = '';
        };
    }

    unless (defined $servers and @{$servers}) {
        $servers = serverList($remoteServices, $user, $password);
        unless ( defined $servers and @{$servers} ) {
            fatal(__x("The account {user} do not have any registered Zentyal servers",
                      user => $user));
        }
    }

    return {
        user => $user,
        password => $password,
        servers => $servers,
    };
}


sub getCredentials
{
    my ($user, $password, $servers, $serverCN, %params) = @_;

    if ($serverCN) {
        _checkServerCN($serverCN, $servers);
    } else {
        $serverCN = askServerCN($servers);
    }

    my $remoteServices = EBox::Global->modInstance('remoteservices');
    my $credentials = backupCredentials(
                                        remoteServices => $remoteServices,
                                        username       => $user,
                                        password       => $password,
                                        serverCN       => $serverCN,
                                       );

    if ($credentials->{type} eq 'basic') {
        my $infoMsg = __s('If you had purchased the Zentyal Disaster Recovery service, besides the configuration you are about to recover, you could have restored the data of the modules.');
        info($infoMsg);
    }

    _setupPasswords($credentials);
    return $credentials;
}

sub getEncryption
{
    my ($credentials, $metadata, %params) = @_;

    if ($credentials->{type} eq 'basic') {
        return;
    }

    my $noEncryption      = $params{noEncryption};
    my $symmetricPassword = $params{symmetricPasasword};
    my $encryptionKey     = $params{encryptionKey};
    my $keyPassphrase     = $params{keyPassphrase};

    if ((not $noEncryption) and
        (not defined $symmetricPassword) and
        (not defined $encryptionKey) )  {

        if (_backupUsesEncryption($metadata)) {
            my $dialogMsg =  __x(
                  'Enter password used to encrypt back up {ser}',
                   ser => $credentials->{commonName});
            $symmetricPassword = password($dialogMsg);
        }
    }

    $credentials = addEncryptionToCredentials($credentials,
                symmetricPassword => $symmetricPassword,
                encryptionKey     => $encryptionKey,
                keyPassphrase     => $keyPassphrase,
                );

    if ($symmetricPassword) {
        # udpate passwords with symmetric password
        _setupPasswords($credentials);
    }
}

sub _backupUsesEncryption
{
    my ($metadata) = @_;
    my $encType = $metadata->{encryptionType};

    return ($encType eq 'symmetric');
}

sub metadata
{
    my ($date) = @_;

    my $dir = metaTmpDir();
    my $file = EBox::EBackup::Subscribed::metaFilenameFromDate($date);
    my $path = $dir . '/' . $file;
    my ($yaml) = YAML::XS::LoadFile($path);

    return $yaml->{backup};
}

sub getBackupDomainsToRestore
{
    my ($credentials, $metadata, $domainsCli) = @_;

    my @domainsCli = @{ $domainsCli };
    my $domains;

    if ($credentials->{type} eq 'subscribed') {
        if (not @domainsCli) {
            # ask to the user
            $domains = askDomainsToRestore($credentials, $metadata);
        } else {
            $domains = { map { $_ => 1 } @domainsCli };
        }

    } else {
        @domainsCli = grep { $_ ne 'configuration' } @domainsCli;
        if (@domainsCli) {
            fatal (__x('The following backup domains could not be restored from a basic subscription: {domains}',
                       domains => "@domainsCli"));
        }
        $domains = { configuration => 1 };
    }

    return $domains;
}

# The last message to finish the restore
sub finishedMessage
{
    my ($credentials) = @_;

    my $msg = '';
    if ( $credentials->{type} eq 'basic' ) {
        $msg = __s('Your configuration backup is now restored!') . "\n\n" .
               __s('Perhaps you could be interested in the Zentyal Disaster Recovery service? This service guarantees that your most business critical data will be stored in a safe remote location and can be recovered easily in case of a disaster.');
    } else {
        $msg = __('Your full backup is now successfully restored!');
    }
    $msg .= "\n\n" . __('You can go now to the Zentyal administration interface to manage your recovered host.');

    info($msg);
}

sub info
{
    my ($msg) = @_;

    EBox::info($msg);
    if ($usesX) {
        _zenityMessage('info', $msg);
    } else {
        print "$msg\n";
    }
}

sub error
{
    my ($msg, $exception) = @_;

    if (defined $exception) {
        EBox::error("Unexpected error: $exception");
    } else {
        EBox::error($msg);
    }
    if ($usesX) {
        _zenityMessage('error', $msg);
    } else {
        print STDERR "$msg\n";
    }
}

sub warning
{
    my ($msg) = @_;

    EBox::warn($msg);
    if ($usesX) {
        _zenityMessage('warning', $msg);
    } else {
        print __x('Warning: {msg}', msg => "$msg\n");
    }
}

sub input
{
    my ($msg, $masked) = @_;

    if ($usesX) {
        return _zenityEntry($msg, $masked);
    } else {
        return terminalPrompt("$msg: ", $masked);
    }
}

sub password
{
    my ($msg) = @_;

    input($msg, 1);
}

sub showException
{
    my ($exception) = @_;

    my $msg = __('Sorry, an unexpected error has occurred. Please contact support and check the /var/log/zentyal/zentyal.log file for further details.');

    error($msg, $exception);

    return $msg;
}

my $_fatalShow = 0;
sub fatal
{
    my ($input) = @_;

    EBox::error("Restore fatal error: $input");

    if (not $_fatalShow) {
        my $msg = showException($input);
        $_fatalShow = 1;
        die $msg;
    }

    die __('Restore process aborted');
}

