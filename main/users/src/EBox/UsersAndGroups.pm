# Copyright (C) 2008-2012 eBox Technologies S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package EBox::UsersAndGroups;

use strict;
use warnings;

use base qw(EBox::Module::Service
            EBox::LdapModule
            EBox::Model::ModelProvider
            EBox::Model::CompositeProvider
            EBox::UserCorner::Provider
          );

use EBox::Global;
use EBox::Util::Random;
use EBox::Ldap;
use EBox::Gettext;
use EBox::Menu::Folder;
use EBox::Menu::Item;
use EBox::Sudo;
use EBox::FileSystem;
use EBox::LdapUserImplementation;
use EBox::Config;
use EBox::UsersAndGroups::Passwords;
use EBox::SOAPClient;
use EBox::UsersAndGroups::User;

use Digest::SHA1;
use Digest::MD5;
use Crypt::SmbHash;
use Sys::Hostname;

use Error qw(:try);
use File::Copy;
use File::Slurp;
use File::Temp qw/tempfile/;
use Perl6::Junction qw(any);
use String::ShellQuote;
use Fcntl qw(:flock);

use constant SYSMINUID      => 1900;
use constant SYSMINGID      => 1900;
use constant MINUID         => 2000;
use constant MINGID         => 2000;
use constant MAXGROUPLENGTH => 128;

use constant USERSDN        => 'ou=Users';
use constant GROUPSDN       => 'ou=Groups';
use constant LIBNSSLDAPFILE => '/etc/ldap.conf';
use constant SECRETFILE     => '/etc/ldap.secret';
use constant DEFAULTGROUP   => '__USERS__';
use constant CA_DIR         => EBox::Config::conf() . 'ssl-ca/';
use constant SSL_DIR        => EBox::Config::conf() . 'ssl/';
use constant CERT           => SSL_DIR . 'master.cert';
use constant AUTHCONFIGTMPL => '/etc/auth-client-config/profile.d/acc-ebox';
use constant QUOTA_PROGRAM  => EBox::Config::scripts('users') . 'user-quota';

use constant LDAP_CONFDIR    => '/etc/ldap/slapd.d/';
use constant LDAP_DATADIR    => '/var/lib/ldap/';
use constant LDAP_USER     => 'openldap';
use constant LDAP_GROUP    => 'openldap';

sub _create
{
    my $class = shift;
    my $self = $class->SUPER::_create(name => 'users',
                                      printableName => __n('Users and Groups'),
                                      @_);
    bless($self, $class);
    return $self;
}

# Method: actions
#
#       Override EBox::ServiceModule::ServiceInterface::actions
#
sub actions
{
    my ($self) = @_;

    my @actions;

    push(@actions,
            {
            'action' => __('Your LDAP database will be populated with some basic organizational units'),
            'reason' => __('Zentyal needs this organizational units to add users and groups into them.'),
            'module' => 'users'
            },
        );

    # FIXME: This probably won't work if PAM is enabled after enabling the module
    if ($self->model('PAM')->enable_pamValue()) {
        push(@actions,
                {
                 'action' => __('Configure PAM.'),
                 'reason' => __('Zentyal will give LDAP users system account.'),
                 'module' => 'users'
                }
        );
    }
    return \@actions;
}

# Method: usedFiles
#
#       Override EBox::Module::Service::files
#
sub usedFiles
{
    my ($self) = @_;
    my @files = ();

    push(@files,
        {
            'file' => '/etc/nsswitch.conf',
            'reason' => __('To make NSS use LDAP resolution for user and '.
                'group accounts. Needed for Samba PDC configuration.'),
            'module' => 'users'
        },
        {
            'file' => LIBNSSLDAPFILE,
            'reason' => __('To let NSS know how to access LDAP accounts.'),
            'module' => 'users'
        },
        {
            'file' => '/etc/fstab',
            'reason' => __('To add quota support to /home partition.'),
            'module' => 'users'
        },
        {
            'file' => '/etc/default/slapd',
            'reason' => __('To make LDAP listen on TCP and Unix sockets.'),
            'module' => 'users'
        },
        {
            'file' => SECRETFILE,
            'reason' => __('To copy LDAP admin password generated by ' .
                'Zentyal and allow other modules to access LDAP.'),
            'module' => 'users'
        },
    );

    return \@files;
}

# Method: initialSetup
#
# Overrides:
#   EBox::Module::Base::initialSetup
#
sub initialSetup
{
    my ($self, $version) = @_;

    # Create default rules and services
    # only if installing the first time
    unless ($version) {
        my $fw = EBox::Global->modInstance('firewall');

        $fw->addInternalService(
                'name' => 'ldap',
                'description' => 'LDAP',
                'protocol' => 'tcp',
                'sourcePort' => 'any',
                'destinationPort' => 389,
                'target'  => 'deny',
                );
        $fw->saveConfigRecursive();
    }

    # Execute initial-setup script
    $self->SUPER::initialSetup($version);
}

# Method: enableActions
#
#   Override EBox::Module::Service::enableActions
#
sub enableActions
{
    my ($self) = @_;

    # Stop slapd daemon
    EBox::Sudo::root(
        'invoke-rc.d slapd stop || true',
        'stop ebox.slapd        || true',
        'cp /usr/share/zentyal-users/slapd.default.no /etc/default/slapd'
    );

    my $dn = 'dc=zentyal,dc=com';
    my $password = $self->_genPassword(EBox::Config::conf() . 'ldap.passwd');
    my $password_ro = $self->_genPassword(EBox::Config::conf() . 'ldap_ro.passwd');
    my $opts = [
        'dn' => $dn,
        'password' => $password,
        'password_ro' => $password_ro,
    ];

    # Prepare ldif files
    my $LDIF_CONFIG = EBox::Config::tmp() . "slapd-config.ldif";
    my $LDIF_DB = EBox::Config::tmp() . "slapd-database.ldif";

    EBox::Module::Base::writeConfFileNoCheck($LDIF_CONFIG, "users/config.ldif.mas", $opts);
    EBox::Module::Base::writeConfFileNoCheck($LDIF_DB, "users/database.ldif.mas", $opts);

    EBox::info('Creating LDAP database...');
    try {
        EBox::Sudo::root(
            # Remove current database (if any)
            'rm -rf ' . LDAP_CONFDIR . ' ' . LDAP_DATADIR,
            'rm -rf ' . LDAP_CONFDIR . ' ' . LDAP_DATADIR,
            'mkdir -p ' . LDAP_CONFDIR . ' ' . LDAP_DATADIR,
            'chmod 750 ' . LDAP_CONFDIR . ' ' . LDAP_DATADIR,

            # Create database (config + structure)
            'slapadd -F ' . LDAP_CONFDIR . " -b cn=config -l $LDIF_CONFIG",
            'slapadd -F ' . LDAP_CONFDIR . " -b $dn -l $LDIF_DB",

            # Fix permissions and clean temp files
            'chown -R openldap.openldap ' . LDAP_CONFDIR . ' ' . LDAP_DATADIR,
            "rm -f $LDIF_CONFIG $LDIF_DB",
        );
    }
    catch EBox::Exceptions::Sudo::Command with {
        my $exception = shift;
        EBox::error('Trying to setup ldap failed, exit value: ' .
                $exception->exitValue());
        throw EBox::Exceptions::External(__('Error while creating users and groups database'));
    };

    # Setup NSS (needed if some user is added before save changes)
    $self->_setConf();

    $self->_manageService('start');
    $self->ldap->clearConn();

    # Create default group
    $self->addGroup(DEFAULTGROUP, 'All users', 1);

    # Perform LDAP actions (schemas, indexes, etc)
    EBox::info('Performing first LDAP actions');
    try {
        $self->performLDAPActions();
    } otherwise {
        throw EBox::Exceptions::External(__('Error performing users initialization'));
    };

    # Execute enable-module script
    $self->SUPER::enableActions();

    # mark apache as changed to avoid problems with getpwent calls, it needs
    # to be restarted to be aware of the new nsswitch conf
    EBox::Global->modInstance('apache')->setAsChanged();
}


# Generate, store in the given file and return a password
sub _genPassword
{
    my ($self, $file) = @_;

    my $pass = EBox::Util::Random::generate(20);
    my ($login,$password,$uid,$gid) = getpwnam('ebox');
    EBox::Module::Base::writeFile($file, $pass,
            { mode => '0600', uid => $uid, gid => $gid });

    return $pass;
}


# Method: wizardPages
#
#   Override EBox::Module::Base::wizardPages
#
sub wizardPages
{
    my ($self) = @_;
    return [{ page => '/UsersAndGroups/Wizard/Users', order => 300 }];
}


# Method: _setConf
#
#       Override EBox::Module::Service::_setConf
#
sub _setConf
{
    my ($self) = @_;

    my $ldap = $self->ldap;
    EBox::Module::Base::writeFile(SECRETFILE, $ldap->getPassword(),
        { mode => '0600', uid => 0, gid => 0 });

    my  $dn = $ldap->dn;
    my $nsspw = read_file(EBox::Config::conf() . 'ldap_ro.passwd');
    my @array = ();
    push(@array, 'ldap' => EBox::Ldap::LDAPI);
    push(@array, 'basedc'    => $dn);
    push(@array, 'binddn'    => 'cn=zentyalro,' . $dn);
    push(@array, 'bindpw'    => $nsspw);
    push(@array, 'rootbinddn'=> 'cn=zentyal,' . $dn);
    push(@array, 'usersdn'   => USERSDN . ',' . $dn);
    push(@array, 'groupsdn'  => GROUPSDN . ',' . $dn);
    push(@array, 'computersdn' => 'ou=Computers,' . $dn);

    $self->writeConfFile(LIBNSSLDAPFILE, "users/ldap.conf.mas",
            \@array);

    $self->_setupNSSPAM();
}

sub _setupNSSPAM
{
    my ($self) = @_;

    my @array;
    my $umask = EBox::Config::configkey('dir_umask');
    push (@array, 'umask' => $umask);

    $self->writeConfFile(AUTHCONFIGTMPL, 'users/acc-ebox.mas',
               \@array);

    my $enablePam = $self->model('PAM')->enable_pamValue();
    my @cmds;
    push (@cmds, 'auth-client-config -a -p ebox');

    unless ($enablePam) {
        push (@cmds, 'auth-client-config -a -p ebox -r');
    }

    push (@cmds, 'auth-client-config -t nss -p ebox');
    EBox::Sudo::root(@cmds);
}


# Method: editableMode
#
#       Check if users and groups can be edited.
#
#       Returns true if mode is master or disabled ad-sync
#
sub editableMode
{
    my ($self) = @_;

    return 1; # TODO check sync providers
}

# Method: _daemons
#
#       Override EBox::Module::Service::_daemons
#
sub _daemons
{
    my ($self) = @_;

    return [
        { 'name' => 'ebox.slapd' },
    ];
}

# Method: _enforceServiceState
#
#       Override EBox::Module::Service::_enforceServiceState
#
sub _enforceServiceState
{
    my ($self) = @_;
    $self->SUPER::_enforceServiceState();

    # Clear LDAP connection
    $self->ldap->clearConn();
}

# Method: modelClasses
#
#       Override <EBox::Model::ModelProvider::modelClasses>
#
sub modelClasses
{
    return [
        'EBox::UsersAndGroups::Model::Mode',
        'EBox::UsersAndGroups::Model::Users',
        'EBox::UsersAndGroups::Model::Groups',
        'EBox::UsersAndGroups::Model::Password',
        'EBox::UsersAndGroups::Model::Slaves',
        'EBox::UsersAndGroups::Model::PendingSync',
        'EBox::UsersAndGroups::Model::ForceSync',
        'EBox::UsersAndGroups::Model::LdapInfo',
        'EBox::UsersAndGroups::Model::PAM',
        'EBox::UsersAndGroups::Model::ADSyncSettings',
        'EBox::UsersAndGroups::Model::AccountSettings',
    ];
}

# Method: compositeClasses
#
#       Override <EBox::Model::CompositeProvider::compositeClasses>
#
sub compositeClasses
{
    return [
        'EBox::UsersAndGroups::Composite::Settings',
        'EBox::UsersAndGroups::Composite::SlaveInfo',
        'EBox::UsersAndGroups::Composite::UserTemplate',
    ];
}


# Method: groupsDn
#
#       Returns the dn where the groups are stored in the ldap directory
#       Accepts an optional parameter as base dn instead of getting it
#       from the local LDAP repository
#
# Returns:
#
#       string - dn
#
sub groupsDn
{
    my ($self, $dn) = @_;
    unless(defined($dn)) {
        $dn = $self->ldap->dn();
    }
    return GROUPSDN . "," . $dn;
}


# Method: groupDn
#
#    Returns the dn for a given group. The group don't have to existst
#
#   Parameters:
#       group
#
#  Returns:
#     dn for the group
sub groupDn
{
    my ($self, $group) = @_;
    $group or throw EBox::Exceptions::MissingArgument('group');

    my $dn = "cn=$group," .  $self->groupsDn;
    return $dn;
}

# Method: usersDn
#
#       Returns the dn where the users are stored in the ldap directory.
#       Accepts an optional parameter as base dn instead of getting it
#       from the local LDAP repository
#
# Returns:
#
#       string - dn
#
sub usersDn
{
    my ($self, $dn) = @_;
    unless(defined($dn)) {
        $dn = $self->ldap->dn();
    }
    return USERSDN . "," . $dn;
}

# Method: userDn
#
#    Returns the dn for a given user. The user don't have to existst
#
#   Parameters:
#       user
#
#  Returns:
#     dn for the user
sub userDn
{
    my ($self, $user) = @_;
    $user or throw EBox::Exceptions::MissingArgument('user');

    my $dn = "uid=$user," .  $self->usersDn;
    return $dn;
}



# Method: userExists
#
#       Checks if a given user exists
#
# Parameters:
#
#       user - user name
#
# Returns:
#
#       boolean - true if it exists, otherwise false
#
sub userExists # (user)
{
    my ($self, $user) = @_;

    my %attrs = (
                 base => $self->usersDn,
                 filter => "(uid=$user)",
                 scope => 'one'
                );

    my $result = $self->ldap->search(\%attrs);

    return ($result->count > 0);
}


# Method: uidExists
#
#       Checks if a given uid exists
#
# Parameters:
#
#       uid - uid number to check
#
# Returns:
#
#       boolean - true if it exists, otherwise false
#
sub uidExists # (uid)
{
    my ($self, $uid) = @_;

    my %attrs = (
                 base => $self->usersDn,
                 filter => "(uidNumber=$uid)",
                 scope => 'one'
                );

    my $result = $self->ldap->search(\%attrs);

    return ($result->count > 0);
}


sub initUser
{
    my ($self, $user, $password) = @_;

    my $userInfo = $self->userInfo($user);
    my $mk_home = EBox::Config::configkey('mk_home');
    $mk_home = 'yes' unless $mk_home;
    if ($mk_home eq 'yes') {
        my $home = $userInfo->{'homeDirectory'};
        if ($home and ($home ne '/dev/null') and (not -e $home)) {
            my @cmds;

            my $quser = shell_quote($user);
            my $qhome = shell_quote($home);
            my $group = DEFAULTGROUP;
            push(@cmds, "mkdir -p `dirname $qhome`");
            push(@cmds, "cp -dR --preserve=mode /etc/skel $qhome");
            push(@cmds, "chown -R $quser:$group $qhome");

            my $dir_umask = oct(EBox::Config::configkey('dir_umask'));
            my $perms = sprintf("%#o", 00777 &~ $dir_umask);
            push(@cmds, "chmod $perms $qhome");

            EBox::Sudo::root(@cmds);
        }
    }

    my $uid = $userInfo->{'uid'};

    my $quota = $userInfo->{'quota'};
    defined $quota or $quota = 0;
    $self->_setFilesystemQuota($uid, $quota);

    # Tell modules depending on users and groups
    # a new new user is created
    my @mods = @{$self->_modsLdapUserBase()};

    foreach my $mod (@mods) {
        $mod->_addUser($user, $password);
    }
}

sub _checkQuota
{
    my ($quota) = @_;

    ($quota =~ /^\s*$/) and return undef;
    ($quota =~ /\D/) and return undef;
    return 1;
}

sub _setFilesystemQuota
{
    my ($self, $uid, $userQuota) = @_;
    my $quota = $userQuota * 1024;
    EBox::Sudo::root(QUOTA_PROGRAM . " -s $uid $quota");
}

sub _modifyUserQuota
{
    my ($self, $user) = @_;

    my $username = $user->{'username'};
    my $dn = $self->userDn($username);
    my $quota = $user->{'quota'};
    my $userInfo = $self->userInfo($username);

    $self->_changeAttribute($dn, 'quota', $quota);
    $self->_setFilesystemQuota($userInfo->{'uid'}, $quota);
}

sub updateUser
{
    my ($self, $user, $password) = @_;

    # Tell modules depending on users and groups
    # a user  has been updated
    my @mods = @{$self->_modsLdapUserBase()};

    foreach my $mod (@mods){
        $mod->_modifyUser($user, $password);
    }
}

# Method: modifyUser
#
#       Modifies  user's attributes
#
# Parameters:
#
#       user - hash ref containing: 'user' (user name), 'givenname', 'surname',
#       'password', and comment. The only mandatory parameter is 'user' the
#       other attribute parameters would be ignored if they are missing.
#
sub modifyUser
{
    my ($self, $user) = @_;

    my $username = $user->{'username'};
    my $dn = $self->userDn($username);

    # Verify user exists
    unless ($self->userExists($user->{'username'})) {
        throw EBox::Exceptions::DataNotFound('data'  => __('user name'),
                                             'value' => $username);
    }

    if (exists $user->{'quota'} and
        (not _checkQuota($user->{'quota'}))) {
        throw EBox::Exceptions::InvalidData('data' => __('user quota'),
                                            'value' => $user->{'quota'},
                                            'advice' => __(
            'User quota must be an integer. To set an unlimited quota, enter zero.'
                                                          ),
                                           );
    }

    foreach my $field (keys %{$user}) {
        if ($field eq 'comment') {
            $self->_changeAttribute($dn, 'description', $user->{'comment'});
        } elsif ($field eq 'givenname') {
            $self->_changeAttribute($dn, 'givenName', $user->{'givenname'});
        } elsif ($field eq 'surname') {
            $self->_changeAttribute($dn, 'sn', $user->{'surname'});
        } elsif ($field eq 'fullname') {
            $self->_changeAttribute($dn, 'cn', $user->{'fullname'});
        } elsif ($field eq 'quota') {
            $self->_modifyUserQuota($user);
        } elsif ($field eq 'password') {
            $self->_modifyUserPwd($user->{'username'}, $user->{'password'});
        }
    }
    $self->updateUser($username, $user->{'password'});
}

# Method: delUser
#
#       Removes a given user
#
# Parameters:
#
#       user - user name to be deleted
#
sub delUser # (user)
{
    my ($self, $user) = @_;

    # Verify user exists
    unless ($self->userExists($user)) {
        throw EBox::Exceptions::DataNotFound('data' => __('user name'),
                                             'value' => $user);
    }

    # Delete user from groups
    foreach my $group (@{$self->groupsOfUser($user)}) {
        $self->delUserFromGroup($user, $group);
    }

    my @mods = @{$self->_modsLdapUserBase()};

    # Tell modules depending on users and groups
    # an user is to be deleted
    foreach my $mod (@mods) {
        $mod->_delUser($user);
    }

    # remove home directory
    #my $userInfo = $self->userInfo($user);
    #my $home = $userInfo->{homeDirectory};
    # TODO: We need to ask with a confirmation dialog before doing this!
    #EBox::Sudo::root("rm -rf $home");

    # Delete user
    my $r = $self->ldap->delete("uid=" . $user . "," . $self->usersDn);
}

# Method: userInfo
#
#       Returns a hash ref containing the inforamtion for a given user
#
# Parameters:
#
#       user - user name to gather information
#       entry - *optional* ldap entry for the user
#
# Returns:
#
#       hash ref - holding the keys: 'username', 'givenname', 'surname', 'fullname'
#      password', 'homeDirectory', 'uid' and 'group'
#
sub userInfo # (user, entry)
{
    my ($self, $user, $entry) = @_;

    # Verify user  exists
    unless ($self->userExists($user)) {
        throw EBox::Exceptions::DataNotFound('data' => __('user name'),
                                             'value' => $user);
    }

    # If $entry is undef we make a search to get the object, otherwise
    # we already have the entry
    unless ($entry) {
        my %args = (
           base => $self->usersDn,
           filter => "(uid=$user)",
           scope => 'one',
           attrs => ['*'],
        );

        my $result = $self->ldap->search(\%args);
        $entry = $result->entry(0);
    }

    # Mandatory data
    my $userinfo = {
        username => $entry->get_value('uid'),
        fullname => $entry->get_value('cn'),
        surname => $entry->get_value('sn'),
        password => $entry->get_value('userPassword'),
        homeDirectory => $entry->get_value('homeDirectory'),
        uid => $entry->get_value('uidNumber'),
        group => $entry->get_value('gidNumber'),
        quota => $entry->get_value('quota'),
        extra_passwords => {},
    };

    foreach my $attr ($entry->attributes) {
        if ($attr =~ m/^ebox(.*)Password$/) {
            my $format = lc($1);
            $userinfo->{extra_passwords}->{$format} = $entry->get_value($attr);
        }
    }

    # Optional Data
    my $givenName = $entry->get_value('givenName');
    if ($givenName) {
        $userinfo->{'givenname'} = $givenName;
    } else {
        $userinfo->{'givenname'} = '';
    }
    my $desc = $entry->get_value('description');
    if ($desc) {
        $userinfo->{'comment'} = $desc;
    } else {
        $userinfo->{'comment'} = '';
    }

    return $userinfo;
}


# Method: users
#
#       Returns an array containing all the users (not system users)
#
# Parameters:
#       system - show system users also (default: false)
#
# Returns:
#
#       array ref - holding the users. Each user is represented by a hash reference
#       with the same format than the return value of userInfo
#
sub users
{
    my ($self, $system) = @_;

    return [] if (not $self->isEnabled());

    my %args = (
        base => $self->baseDn,
        filter => 'objectclass=*',
        scope => 'sub',
    );

    my $result = $self->ldap->search(\%args);

    my @users = ();
    foreach my $entry ($result->sorted('uid'))
    {
        my $user = new EBox::UsersAndGroups::User($entry);

        # Include system users?
        next if (not $system and $user->system());

        @users = (@users, $user);
    }

    return \@users;
}

# Method: groupExists
#
#       Checks if a given group name exists
#
# Parameters:
#
#       group - group name
#
# Returns:
#
#       boolean - true if it exists, otherwise false
#
sub groupExists # (group)
{
    my ($self, $group) = @_;

    my %attrs = (
                 base => $self->groupsDn,
                 filter => "(cn=$group)",
                 scope => 'one'
                );

    my $result = $self->ldap->search(\%attrs);

    return ($result->count > 0);
}

# Method: gidExists
#
#       Checks if a given gid number exists
#
# Parameters:
#
#       gid - gid number
#
# Returns:
#
#       boolean - true if it exists, otherwise false
#
sub gidExists
{
    my ($self, $gid) = @_;

    my %attrs = (
                 base => $self->groupsDn,
                 filter => "(gidNumber=$gid)",
                 scope => 'one'
                );

    my $result = $self->ldap->search(\%attrs);

    return ($result->count > 0);
}

# Method: lastGid
#
#       Returns the last gid used.
#
# Parameters:
#
#       system - boolan: if true, it returns the last gid for system users,
#       otherwise the last gid for normal users
#
# Returns:
#
#       string - last gid
#
sub lastGid # (gid)
{
    my ($self, $system) = @_;

    my %args = (
                base => $self->groupsDn,
                filter => '(objectclass=posixGroup)',
                scope => 'one',
                attrs => ['gidNumber']
               );

    my $result = $self->ldap->search(\%args);
    my @users = $result->sorted('gidNumber');

    my $gid = -1;
    foreach my $user (@users) {
        my $currgid = $user->get_value('gidNumber');
        if ($system) {
                        last if ($currgid > MINGID);
                    } else {
                        next if ($currgid < MINGID);
                    }

        if ( $currgid > $gid){
            $gid = $currgid;
        }
    }

    if ($system) {
        return ($gid < SYSMINUID ?  SYSMINUID : $gid);
    } else {
        return ($gid < MINGID ?  MINGID : $gid);
    }
}

# Method: addGroup
#
#       Adds a new group
#
# Parameters:
#
#       group - group name
#       comment - comment's group
#       system - boolan: if true it adds the group as system group,
#       otherwise as normal group
#
sub addGroup # (group, comment, system)
{
    my ($self, $group, $comment, $system, %params) = @_;

    if (length($group) > MAXGROUPLENGTH) {
        throw EBox::Exceptions::External(
                        __x("Groupname must not be longer than {maxGroupLength} characters",
                            maxGroupLength => MAXGROUPLENGTH));
    }

    if (($group eq DEFAULTGROUP) and (not $system)) {
        throw EBox::Exceptions::External(
                        __('The group name is not valid because it is used' .
                           ' internally'));
        }

    unless (_checkName($group)) {
        throw EBox::Exceptions::InvalidData(
                                            'data' => __('group name'),
                                            'value' => $group);
        }
    # Verify group exists
    if ($self->groupExists($group)) {
        throw EBox::Exceptions::DataExists('data' => __('group name'),
                                           'value' => $group);
    }
    #FIXME
    my $gid = exists $params{gidNumber} ?
        $params{gidNumber} :
            $self->_gidForNewGroup($system);

    $self->_checkGid($gid, $system);

    my %args = (
                attr => [
                         'cn'        => $group,
                         'gidNumber'   => $gid,
                         'objectclass' => ['posixGroup', 'zentyalGroup'],
                        ]
               );

    my $dn = "cn=" . $group ."," . $self->groupsDn;
    my $r = $self->ldap->add($dn, \%args);

    $self->_changeAttribute($dn, 'description', $comment);

    unless ($system) {
        # Tell modules depending on users and groups
        # a new group is created
        my @mods = @{$self->_modsLdapUserBase()};

        foreach my $mod (@mods){
            $mod->_addGroup($group);
        }
    }

    if ( -f '/etc/init.d/nscd' ) {
        try {
            EBox::Sudo::root('/etc/init.d/nscd reload');
        } otherwise {};
    }
}

sub _gidForNewGroup
{
    my ($self, $system) = @_;

    my $gid;
    if ($system) {
        $gid = $self->lastGid(1) + 1;
        if ($gid == MINGID) {
            throw EBox::Exceptions::Internal(
                                __('Maximum number of system users reached'));
        }
    } else {
        $gid = $self->lastGid + 1;
    }

    return $gid;
}


sub _checkGid
{
    my ($self, $gid, $system) = @_;

    if ($gid < MINGID) {
        if (not $system) {
            throw EBox::Exceptions::External(
                 __x('Incorrect GID {gid} for a group . GID must be equal or greater than {min}',
                     gid => $gid,
                     min => MINGID,
                    )
                );
        }
    }
    else {
        if ($system) {
            throw EBox::Exceptions::External(
               __x('Incorrect GID {gid} for a system group . GID must be lesser than {max}',
                    gid => $gid,
                    max => MINGID,
                   )
               );
        }
    }
}



sub updateGroup
{
    my ($self, $group, @params) = @_;

    # Tell modules depending on groups and groups
    # a group  has been updated
    my @mods = @{$self->_modsLdapUserBase()};

    foreach my $mod (@mods){
        $mod->_modifyGroup($group, @params);
    }
}

# Method: modifyGroup
#
#       Modifies a group
#
# Parameters:
#
#       hash ref - holding the keys 'groupname' and 'comment'. At the moment
#       comment is the only modifiable attribute
#
sub modifyGroup
{
    my ($self, $groupdata, @params) = @_;

    my $cn = $groupdata->{'groupname'};
    my $dn = "cn=$cn," . $self->groupsDn;
    # Verify group  exists
    unless ($self->groupExists($cn)) {
        throw EBox::Exceptions::DataNotFound('data'  => __('user name'),
                                             'value' => $cn);
    }

    $self->_changeAttribute($dn, 'description', $groupdata->{'comment'});
}


# Method: delGroup
#
#       Removes a given group
#
# Parameters:
#
#       group - group name to be deleted
#
sub delGroup # (group)
{
    my ($self, $group) = @_;

    unless ($self->groupExists($group)) {
        throw EBox::Exceptions::DataNotFound('data' => __('group name'),
                'value' => $group);
    }

    my @mods = @{$self->_modsLdapUserBase()};

    # Tell modules depending on users and groups
    # a group is to be deleted
    foreach my $mod (@mods){
        $mod->_delGroup($group);
    }
    my $dn = "cn=" . $group . "," . $self->groupsDn;
    my $result = $self->ldap->delete($dn);
}

# Method: groupInfo
#
#       Returns a hash ref containing the inforamtion for a given group
#
# Parameters:
#
#       group - group name to gather information
#       entry - *optional* ldap entry for the group
#
# Returns:
#
#       hash ref - holding the keys: 'groupname', 'comment' and 'gid'
sub groupInfo # (group)
{
    my ($self, $group) = @_;

    # Verify user don't exists
    unless ($self->groupExists($group)) {
        throw EBox::Exceptions::DataNotFound('data' => __('user name'),
                                             'value' => $group);
    }

    my %args = (
                base => $self->groupsDn,
                filter => "(cn=$group)",
                scope => 'one',
                attrs => ['cn', 'gidNumber', 'description']
               );

    my $result = $self->ldap->search(\%args);

    my $entry = $result->entry(0);
    # Mandatory data
    my $groupinfo = {
                     groupname => $entry->get_value('cn'),
                     gid => $entry->get_value('gidNumber'),
                    };


    my $desc = $entry->get_value('description');
    if ($desc) {
        $groupinfo->{'comment'} = $desc;
    } else {
        $groupinfo->{'comment'} = "";
    }

    return $groupinfo;

}

# Method: groups
#
#       Returns an array containing all the groups
#
#   Parameters:
#       system - show system groups (default: false)
#
# Returns:
#
#       array - holding the groups
#
# Warning:
#
#   the group hashes are NOT the sames that we get from groupInfo, the keys are:
#     account(group name), desc (description) and gid
sub groups
{
    my ($self, $system) = @_;

    return () if (not $self->isRunning());

    defined $system or $system = 0;

    my %args = (
                base => $self->groupsDn,
                filter => '(objectclass=*)',
                scope => 'one',
                attrs => ['cn', 'gidNumber', 'description']
               );

    my $result = $self->ldap->search(\%args);

    my @groups = ();
    foreach ($result->sorted('cn')) {
        if (not $system) {
            next if ($_->get_value('gidNumber') < MINGID);
        }


        my $info = {
                    'account' => $_->get_value('cn'),
                    'gid' => $_->get_value('gidNumber'),
                   };

        my $desc = $_->get_value('description');
        if ($desc) {
            $info->{'desc'} = $desc;
        }

        push @groups, $info;
    }

    return @groups;
}

# Method: addUserToGroup
#
#       Adds a user to a given group
#
# Parameters:
#
#       user - user name to add to the group
#       group - group name
#
# Exceptions:
#
#       DataNorFound - If user or group don't exist
sub addUserToGroup # (user, group)
{
    my ($self, $user, $group) = @_;

    unless ($self->userExists($user)) {
        throw EBox::Exceptions::DataNotFound('data' => __('user name'),
                                             'value' => $user);
    }

    unless ($self->groupExists($group)) {
        throw EBox::Exceptions::DataNotFound('data' => __('group name'),
                                             'value' => $group);
    }

    my $dn = "cn=" . $group . "," . $self->groupsDn;
    my $userDn = "uid=" . $user . "," . $self->usersDn;

    my %attrs = ( add => { member => $userDn } );
    $self->ldap->modify($dn, \%attrs);

    $self->updateGroup($group, op => 'add', user => $user);
}

# Method: delUserFromGroup
#
#       Removes a user from a group
#
# Parameters:
#
#       user - user name to remove  from the group
#       group - group name
#
# Exceptions:
#
#       DataNorFound - If user or group don't exist
sub delUserFromGroup # (user, group)
{
    my ($self, $user, $group) = @_;

    unless ($self->userExists($user)) {
        throw EBox::Exceptions::DataNotFound('data' => __('user name'),
                                             'value' => $user);
    }

    unless ($self->groupExists($group)) {
        throw EBox::Exceptions::DataNotFoud('data' => __('group name'),
                                            'value' => $group);
    }

    my $dn = "cn=" . $group . "," . $self->groupsDn;
    my $userDn = "uid=" . $user . "," . $self->usersDn;
    my %attrs = ( delete => {  member => $userDn  } );
        $self->ldap->modify($dn, \%attrs);

    $self->updateGroup($group, op => 'del', user => $user);
}

# Method: groupsOfUser
#
#       Given a user it returns all the groups which the user belongs to
#
# Parameters:
#
#       user   - user name
#       system - show system groups (default: false) *optional*
#
# Returns:
#
#       array ref - holding the groups
#
# Exceptions:
#
#       DataNotFound - If user does not exist
#
sub groupsOfUser # (user, system?)
{
    my ($self, $user, $system) = @_;
    defined $system or $system = 0;

    return $self->_ldapSearchUserGroups($user, $system, 0);
}

# Method: groupsNotOfUser
#
#       Given a user it returns all the groups which the user doesn't belong to
#
# Parameters:
#
#       user   - user name
#       system - show system groups (default: false) *optional*
#
# Returns:
#
#       array ref - holding the groups
#
# Exceptions:
#
#       DataNotFound - If user does not  exist
#
sub groupsNotOfUser # (user, system?)
{
    my ($self, $user, $system) = @_;
    defined $system or $system = 0;

    return $self->_ldapSearchUserGroups($user, $system, 1);
}

sub _ldapSearchUserGroups # (user, system, inverse)
{
    my ($self, $user, $system, $inverse) = @_;

    unless ($self->userExists($user)) {
        throw EBox::Exceptions::DataNotFound('data' => __('user name'),
                                             'value' => $user);
    }

    my $filter = '&(objectClass=*)';
    my $userDn = "uid=" . $user . "," . $self->usersDn;
    if ($inverse) {
        $filter .= "(!(member=$userDn))"
    } else {
        $filter .= "(member=$userDn)";
    }

    my %attrs = (
                 base => $self->groupsDn,
                 filter => $filter,
                 scope => 'one',
                 attrs => ['cn', 'gidNumber']
                );

    my $result = $self->ldap->search(\%attrs);

    my @groups;
    foreach my $entry ($result->entries) {
        if (not $system) {
            next if ($entry->get_value('gidNumber') < MINGID);
        }
        push @groups, $entry->get_value('cn');
    }

    return \@groups;
}

# Method: usersInGroup
#
#       Given a group it returns all the users belonging to it
#
# Parameters:
#
#       group - group name
#
# Returns:
#
#       array ref - holding the users
#
# Exceptions:
#
#       DataNorFound - If group does not  exist
sub usersInGroup # (group)
{
    my ($self, $group) = @_;

    unless ($self->groupExists($group)) {
        throw EBox::Exceptions::DataNotFound('data' => __('group name'),
                                             'value' => $group);
    }

    my %attrs = (
                 base => $self->groupsDn,
                 filter => "(cn=$group)",
                 scope => 'one',
                 attrs => ['member']
                );

    my $result = $self->ldap->search(\%attrs);

    my @users;
    foreach my $res ($result->sorted('member')){
        my $userDn = $res->get_value('member');
        if ($userDn =~ m/uid=([^,]*),/) {
            push @users, $1;
        }
    }

    return \@users;
}

# Method: usersNotInGroup
#
#       Given a group it returns all the users who not belonging to it
#
# Parameters:
#
#       group - group name
#
# Returns:
#
#       array  - holding the groups
#
sub usersNotInGroup # (group)
{
    my ($self, $groupname) = @_;

    my $grpusers = $self->usersInGroup($groupname);
    my @allusers = $self->users();

    my @users;
    foreach my $user (@allusers){
        my $uid = $user->{username};
        unless (grep (/^$uid$/, @{$grpusers})){
            push @users, $uid;
        }
    }

    return @users;
}


# Method: gidGroup
#
#       Given a gid number it returns its group name
#
# Parameters:
#
#       gid - gid number
#
# Returns:
#
#       string - group name
#
sub gidGroup # (gid)
{
    my ($self, $gid) = @_;

    my %attrs = (
                 base => $self->groupsDn,
                 filter => "(gidNumber=$gid)",
                 scope => 'one',
                 attr => ['cn']
                );

    my $result = $self->ldap->search(\%attrs);

    if ($result->count == 0){
        throw EBox::Exceptions::DataNotFound(
                                             'data' => "Gid", 'value' => $gid);
    }

    return $result->entry(0)->get_value('cn');
}

# Method: groupGid
#
#       Given a group name  it returns its gid number
#
# Parameters:
#
#       group - group name
#
# Returns:
#
#       string - gid number
#
sub groupGid # (group)
{
    my ($self, $group) = @_;

    unless ($self->groupExists($group)) {
        throw EBox::Exceptions::DataNotFound('data' => __('group name'),
                                             'value' => $group);
    }

    my %attrs = (
                 base => $self->groupsDn,
                 filter => "(cn=$group)",
                 scope => 'one',
                 attr => ['cn']
                );

    my $result = $self->ldap->search(\%attrs);

    return $result->entry(0)->get_value('gidNumber');
}

sub _groupIsEmpty
{
    my ($self, $group) = @_;

    my @users = @{$self->usersInGroup($group)};

    return @users ? undef : 1;
}

sub _changeAttribute
{
    my ($self, $dn, $attr, $value) = @_;

    my $valueExists = undef;
    if (defined $value) {
        unless ($value =~ m/^\s*$/) {
            $valueExists = 1;
        }
    }

    my %args = (
            base => $dn,
            filter => 'objectclass=*',
            scope =>  'base'
            );

    my $result = $self->ldap->search(\%args);
    my $entry = $result->pop_entry();
    my $oldvalue = $entry->get_value($attr);

    if (defined $oldvalue) {
        if ($valueExists) {
            if ($value eq $oldvalue) {
                # no changes, nothing to do
                return;
            } else {
                # replace with new value
                $entry->replace($attr => $value);
            }
        } else {
            # delete attribute
            $entry->delete($attr);
        }
    } else {
        if ($valueExists) {
            $entry->add($attr => $value);
        } else {
            # There is no value to add
            return;
        }
    }

    # update changes
    $entry->update($self->ldap->ldapCon);
}


# Returns modules implementing LDAP user base interface
sub _modsLdapUserBase
{
    my ($self) = @_;

    my $global = EBox::Global->modInstance('global');
    my @names = @{$global->modNames};

    my @modules;
    foreach my $name (@names) {
         my $mod = EBox::Global->modInstance($name);

        if ($mod->isa('EBox::LdapModule')) {
            if ($mod->isa('EBox::Module::Service')) {
                if ($name ne $self->name()) {
                    $mod->configured() or
                        next;
                }
            }
            push (@modules, $mod->_ldapModImplementation);
        }
    }

    return \@modules;
}

# Method: defaultUserModels
#
#   Returns all the defaultUserModels from modules implementing
#   <EBox::LdapUserBase>
sub defaultUserModels
{
    my ($self) = @_;
    my @models;
    for my $module  (@{$self->_modsLdapUserBase()}) {
        my $model = $module->defaultUserModel();
        push (@models, $model) if (defined($model));
    }
    return \@models;
}

# Method: allUserAddOns
#
#       Returns all the mason components from those modules implementing
#       the function _userAddOns from EBox::LdapUserBase
#
# Parameters:
#
#       user - username
#
# Returns:
#
#       array ref - holding all the components and parameters
#
sub allUserAddOns # (user)
{
    my ($self, $username) = @_;

    my $global = EBox::Global->modInstance('global');
    my @names = @{$global->modNames};

    my @modsFunc = @{$self->_modsLdapUserBase()};
    my @components;
    foreach my $mod (@modsFunc) {
        my $comp = $mod->_userAddOns($username);
        if ($comp) {
            push (@components, $comp);
        }
    }

    return \@components;
}

# Method: allGroupAddOns
#
#       Returns all the mason components from those modules implementing
#       the function _groupAddOns from EBox::LdapUserBase
#
# Parameters:
#
#       group  - group name
#
# Returns:
#
#       array ref - holding all the components and parameters
#
sub allGroupAddOns
{
    my ($self, $groupname) = @_;

    my $global = EBox::Global->modInstance('global');
    my @names = @{$global->modNames};

    my @modsFunc = @{$self->_modsLdapUserBase()};
    my @components;
    foreach my $mod (@modsFunc) {
        my $comp = $mod->_groupAddOns($groupname);
        push (@components, $comp) if ($comp);
    }

    return \@components;
}

# Method: allLDAPLocalAttributes
#
#       Returns all the ldap local attributes requested by those modules
#       implementing the function _localAttributes from EBox::LdapUserBase
#
# Returns:
#
#       array ref - holding all the attributes
#
sub allLDAPLocalAttributes
{
    my ($self) = @_;

    my @modsFunc = @{$self->_modsLdapUserBase()};
    my @allAttributes;
    foreach my $mod (@modsFunc) {
        push (@allAttributes, @{$mod->_localAttributes()});
    }

    return \@allAttributes;
}

# Method: allWarning
#
#       Returns all the the warnings provided by the modules when a certain
#       user or group is going to be deleted. Function _delUserWarning or
#       _delGroupWarning is called in all module implementing them.
#
# Parameters:
#
#       object - Sort of object: 'user' or 'group'
#       name - name of the user or group
#
# Returns:
#
#       array ref - holding all the warnings
#
sub allWarnings
{
    my ($self, $object, $name) = @_;

    my @modsFunc = @{$self->_modsLdapUserBase()};
    my @allWarns;
    foreach my $mod (@modsFunc) {
        my $warn = undef;
        if ($object eq 'user') {
            $warn = $mod->_delUserWarning($name);
        } else {
            $warn = $mod->_delGroupWarning($name);
        }
                push (@allWarns, $warn) if ($warn);
    }

    return \@allWarns;
}

# Method: _supportActions
#
#       Overrides EBox::ServiceModule::ServiceInterface method.
#
sub _supportActions
{
    return undef;
}

# Method: menu
#
#       Overrides EBox::Module method.
#
sub menu
{
    my ($self, $root) = @_;

    my $folder = new EBox::Menu::Folder('name' => 'UsersAndGroups',
                                        'text' => $self->printableName(),
                                        'separator' => 'Office',
                                        'order' => 510);
    if ($self->configured()) {
        if ($self->editableMode()) {
            $folder->add(new EBox::Menu::Item('url' => 'UsersAndGroups/Users',
                                              'text' => __('Users'), order => 10));
            $folder->add(new EBox::Menu::Item('url' => 'UsersAndGroups/Groups',
                                              'text' => __('Groups'), order => 20));
            $folder->add(new EBox::Menu::Item('url' => 'Users/Composite/UserTemplate',
                                              'text' => __('User Template'), order => 30));
        } else {
            $folder->add(new EBox::Menu::Item(
                        'url' => 'Users/View/Users',
                        'text' => __('Users'), order => 10));
            $folder->add(new EBox::Menu::Item(
                        'url' => 'Users/View/Groups',
                        'text' => __('Groups'), order => 20));
            $folder->add(new EBox::Menu::Item('url' => 'Users/Composite/UserTemplate',
                                              'text' => __('User Template'), order => 30));
        }

        $folder->add(new EBox::Menu::Item(
                    'url' => 'Users/Composite/Settings',
                    'text' => __('LDAP Settings'), order => 40));
    } else {
        $folder->add(new EBox::Menu::Item('url' => 'Users/View/Mode',
                                          'text' => __('Mode'), order => 10));

    }
    $root->add($folder);
}

# EBox::UserCorner::Provider implementation

# Method: userMenu
#
sub userMenu
{
    my ($self, $root) = @_;

    $root->add(new EBox::Menu::Item('url' => 'Users/View/Password',
                                      'text' => __('Password')));
}

# LdapModule implementation
sub _ldapModImplementation
{
    return new EBox::LdapUserImplementation();
}

sub dumpConfig
{
    my ($self, $dir, %options) = @_;

    $self->ldap->dumpLdapMaster($dir);
    if ($options{bug}) {
        my $file = $self->ldap->ldifFile($dir, 'master', 'data');
        $self->_removePasswds($file);
    }
}

sub _usersInEtcPasswd
{
    my ($self) = @_;
    my @users;

    my @lines = File::Slurp::read_file('/etc/passwd');
    foreach my $line (@lines) {
        my ($user) = split ':', $line, 2;
        push @users, $user;
    }

    return \@users;
}

sub restoreBackupPreCheck
{
    my ($self, $dir) = @_;

    my %etcPasswdUsers = map { $_ => 1 } @{ $self->_usersInEtcPasswd() };

    my @usersToRestore = @{ $self->ldap->usersInBackup($dir, 'master') };
    foreach my $user (@usersToRestore) {
        if (exists $etcPasswdUsers{$user}) {
            throw EBox::Exceptions::External(
                                             __x(
'Cannot restore because LDAP user {user} already exists as /etc/passwd user. Delete or rename this user and try again',
                                                 user => $user
                                                )
                                            );
        }
    }
}

sub restoreConfig
{
    my ($self, $dir) = @_;
    return;
    # TODO review/rewrite
}

sub _removePasswds
{
  my ($self, $file) = @_;

  my $anyPasswdAttr = any(qw(
              userPassword
              sambaLMPassword
              sambaNTPassword
              )
          );
  my $passwordSubstitution = "password";

  my $FH_IN;
  open $FH_IN, "<$file" or
      throw EBox::Exceptions::Internal ("Cannot open $file: $!");

  my ($FH_OUT, $tmpFile) = tempfile(DIR => EBox::Config::tmp());

  foreach my $line (<$FH_IN>) {
      my ($attr, $value) = split ':', $line;
      if ($attr eq $anyPasswdAttr) {
          $line = $attr . ': ' . $passwordSubstitution . "\n";
      }

      print $FH_OUT $line;
  }

  close $FH_IN  or
      throw EBox::Exceptions::Internal ("Cannot close $file: $!");
  close $FH_OUT or
      throw EBox::Exceptions::Internal ("Cannot close $tmpFile: $!");

  File::Copy::move($tmpFile, $file);
  unlink $tmpFile;
}

sub minGid
{
    return MINGID;
}

sub defaultQuota
{
    my ($self) = @_;

    my $model = $self->model('AccountSettings');

    my $value = $model->defaultQuotaValue();
    if ($value eq 'defaultQuota_disabled') {
        # FIXME: probably we need to differenciate between unlimited (0) and
        # unset
        $value = 0;
    }

    return $value;
}

sub enableQuota
{
    return (EBox::Config::configkey('enable_quota') ne 'no');
}

# Method: authUser
#
#   try to authenticate the given user with the given password
#
sub authUser
{
    my ($self, $user, $password) = @_;

    my $authorized = 0;
    my $ldap = EBox::Ldap::safeConnect(EBox::Ldap::LDAPI);
    try {
        EBox::Ldap::safeBind($ldap, $self->userDn($user), $password);
        $authorized = 1; # auth ok
    } otherwise {
        $authorized = 0; # auth failed
    };
    return $authorized;
}


sub listUsers
{
    my ($self, $ldap, $dn) = @_;

    my %args = (
        'base' => $self->usersDn($dn),
        'scope' => 'one',
        'filter' => "(objectClass=posixAccount)"
    );
    my $result = $ldap->search(%args);

    my @users = map { $_->get_value('uid') } $result->entries();
    return \@users;
}

sub listGroups
{
    my ($self, $ldap, $dn) = @_;

    my %args = (
        'base' => $self->groupsDn($dn),
        'scope' => 'one',
        'filter' => "(objectClass=posixGroup)"
    );
    my $result = $ldap->search(%args);

    my @groups = map { $_->get_value('cn') } $result->entries();
    return \@groups;
}


sub listSchemas
{
    my ($self, $ldap) = @_;

    my %args = (
        'base' => 'cn=schema,cn=config',
        'scope' => 'one',
        'filter' => "(objectClass=olcSchemaConfig)"
    );
    my $result = $ldap->search(%args);

    my @schemas = map { $_->get_value('cn') } $result->entries();
    return \@schemas;
}


# FIXME delete this method
sub mode
{
    my ($self) = @_;

    return 'master';
}

sub baseDn
{
    my ($ldap) = @_;

    my %args = (
        'base' => '',
        'scope' => 'base',
        'filter' => '(objectclass=*)',
        'attrs' => ['namingContexts']
    );
    my $result = $ldap->search(%args);
    my $entry = ($result->entries)[0];
    my $attr = ($entry->attributes)[0];
    my $dn = $entry->get_value($attr);

    return $dn;
}

sub _loginShell
{
    my ($self) = @_;

    return $self->model('PAM')->login_shellValue();
}

1;
