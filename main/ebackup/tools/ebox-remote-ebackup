#!/usr/bin/perl
# Copyright (C) 2009-2010 eBox Technologies S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Script: ebox-remote-ebackup
#
# This script is called from crontab to carry out a full or incremental
# backup depending on the user configuration
#
# It takes one argument that can be:
#
#   --full (default)
#   --incremental
#   --full-only-once

use strict;
use warnings;

use EBox;
use EBox::Config;
use EBox::Global;
use EBox::Gettext;
use EBox::Sudo;
use EBox::Event;
use EBox::EBackup::Subscribed;

use Error qw(:try);


sub _sendEvent
{
    my ($msg, $level) = @_;

    # Generate event
    my $global = EBox::Global->getInstance(1);
    if ($global->modExists('events')) {
        my $events = $global->modInstance('events');
        if ((defined $events)  and ($events->isRunning())) {
            my $enabled = $events
                ->isEnabledWatcher('EBox::Event::Watcher::EBackup')->value();
            if ($enabled) {
                $events->sendEvent(message => $msg,
                        source  => 'EBackup',
                        level   => $level);
            }
        }
    }
}

sub _sendSuccessEvent
{
    my ($success, $type, $msgError) = @_;
    my $msg;
    my $level;
    
    my $printableMode;
    if ($type eq 'full') {
        $printableMode = __('full');
    } elsif ($type eq 'incremental') {
        $printableMode = __('incremental');
    } else {
        $printableMode = $type;
    }


    if ($success) {
        $msg = __x('Zentyal {mode} backup succeeded',
                    mode => $printableMode);
        $level = 'info';
    } else {
        if ($msgError) {
            $msg = __x("Zentyal {mode} backup failed: {error}",
                       mode  => $printableMode,
                       error => $msgError,
                      );
        } else {
            $msg = __x("Zentyal {mode} backup failed",
                       mode  => $printableMode,
                      );
        }

        $level = 'error';
    }
    _sendEvent( $msg, $level);
}

sub _mangleDuplicityErrorMsg
{
    my ($msg) = @_;

    my $spaceLeftRe =  qr/^Temp space has (\d+) available, backup needs approx (\d+)/;

    if ($msg =~ m/$spaceLeftRe/) {
        my ($avail, $need) = ($1, $2);
        $avail = _bytesToMB($avail);
        $need = _bytesToMB($need);
        my $tmpDir = EBox::EBackup::tempdir();

        return __x(
                   q/Temp directory '{dir}' has {avail} MB available, backup needs approx {need} MB. Either free some space or change temporal directory and volume size settings in {conf}./,
                   dir   => $tmpDir,
                   avail => $avail,
                   need  => $need,
                   conf  => '/etc/zentyal/82ebackup.conf',
                  );

    }
    return $msg;
}

sub _bytesToMB
{
    my ($bytes) = @_;
    return sprintf('%.3f', $bytes/1048576);
}

sub _existsFullBackup
{
    my ($ebackup) = @_;

    my $status = $ebackup->remoteStatus();
    foreach my $st (@{ $status }) {
        if ($st->{type} eq 'Full') {
            return 1;
        }
    }

    return 0;
}

sub usage
{
    print __('Usage:');
    print "\n";
    print "$0 [--full|--incremental|--full-only-once]";
    print "\n";
}

sub _adjustType
{
    my ($ebackup, $type) = @_;

# We need an updated cache to avoid errors while checking the status if backup
# files have been re/moved
#
# We can disable this feature to speed up process when there is not full backup,
# incremetal is specified and status cache is not properly updated it will give a
# "old sigantures not found" error
    $ebackup->remoteGenerateStatusCache();

    if ($type eq 'full-only-once') {
        if (_existsFullBackup($ebackup)) {
            $type = 'incremental';
        } else {
            EBox::info('No full backup detected in archive. We will make a full backup, following backups will be incremental');
            $type = 'full';
        }
    } elsif ($type eq 'incremental') {
        if (not _existsFullBackup($ebackup)) {
            EBox::warn('Incremental backup requested but there are not full backups. Switching to full backup mode');
            $type = 'full';
        }
    }

    return $type;
}

# Return whether there are unsaved changes or not
sub _unsavedChangesWarning
{
    my ($self) = @_;

    my @changed;
    my $global = EBox::Global->getInstance(); # rw instance to get change status
    foreach my $modName (@{ $global->modNames() }) {
        if ($global->modIsChanged($modName)) {
            push @changed, $modName;
        }
    }

    if (@changed) {
        my $mods = join ',', @changed;
        my $msg = __x('Configuration backup skipped because the following modules have unsaved changes: {mods}. The rest of the backup will not be affected',
                      mods => $mods);
        _sendSuccessEvent(0,  $msg);
        print "$msg\n";
        return 1;
    }

    return 0;
}

sub _removeExpiredBackups
{
    my ($ebackup) = @_;
    my $removeArguments = $ebackup->remoteDelOldArguments();
    EBox::Sudo::root($removeArguments);
}

sub _cleanup
{
    my ($ebackup) = @_;

    my $duplicityWrapper = $ebackup->DUPLICITY_WRAPPER();
    my $remoteUrl = $ebackup->_remoteUrl();
    my $cmd = "$duplicityWrapper cleanup --force $remoteUrl";
    EBox::debug('Trying to clean up incomplete backups');
    EBox::Sudo::root($cmd);
}

my $type = 'full';
if ($ARGV[0]) {
    if ($ARGV[0] eq '--incremental') {
        $type = 'incremental';
    } elsif ($ARGV[0] eq '--full') {
        $type = 'full';
    } elsif ($ARGV[0] eq '--full-only-once') {
        $type = 'full-only-once';
    } else {
        print "Invalid argument: " . $ARGV[0];
        print "\n";
        usage();
        exit 1;
    }
}

EBox::init();

my $globalRO = 1;
my $ebackup = EBox::Global->getInstance($globalRO)->modInstance('ebackup');
unless ($ebackup->isEnabled() ) {
    print "Backup module is disabled\n";
    exit 0;
}
unless ($ebackup->configurationIsComplete()) {
    print "Backup module configuration is not completed. Configure it and retry\n";
    exit 0;

}

my $unsavedChanges = _unsavedChangesWarning();

my $mustExit = 0;

try {
    $ebackup->backupProcessLock()
} otherwise {
    my $alreadyMsg = __('Another backup process is running, wait until it finishes and try again');
    print $alreadyMsg;
    print "\n";
    _sendSuccessEvent(0,  $alreadyMsg);
    $mustExit= 1;
};
if ($mustExit) {
    exit $mustExit;
}


try {
   $ebackup->lock() ;
} otherwise {
    $ebackup->backupProcessUnlock();
    my $busyMsg = __('The backup module is busy, retry later');
    print $busyMsg;
    print "\n";
    _sendSuccessEvent(0,  $busyMsg);
    $mustExit =  1;
};



if ($mustExit) {
    exit $mustExit;
}


my $errorMsg;
my $success = 1;
my $configurationDumped = 0;
my $usingCloud = $ebackup->model('RemoteSettings')->row()->valueByName('method') eq 'cloud';
try {
    $type = _adjustType($ebackup, $type);

    if ($type eq 'full') {
        _removeExpiredBackups($ebackup);
    }

    try {
        $ebackup->dumpExtraData($globalRO);
        $configurationDumped = (not $unsavedChanges);
    } otherwise {
        my $ex = @_;
        EBox::error("Error dumping server metadata: $ex. Backup process continues but you won't be able to restore the server configuration with this backup");
    };


    my $backupCmd = $ebackup->remoteArguments($type);
    my $errorMsg;
    my $success = 1;
    try {
        EBox::info('Backing up files to destination');
        EBox::Sudo::root($backupCmd);
        if ($usingCloud) {
            $ebackup->remoteGenerateStatusCache();
            my $availableDomains = $ebackup->availableBackupDomains();
            my @enabledDomains = grep { $availableDomains->{$_}->{enabled} } keys %{$availableDomains};
            my %backupDomains = map
              { $_ => { description   => $availableDomains->{$_}->{description},
                        printableName => $availableDomains->{$_}->{printableName} } }
                @enabledDomains;
            EBox::info('Writing Disaster Recovery metadata');
            EBox::EBackup::Subscribed::writeDRMetadata(
                configurationDumped => $configurationDumped,
                date                => $ebackup->lastBackupDate(),
                backupType          => $type,
                backupDomains       => \%backupDomains,
               );
        }

    } catch EBox::Exceptions::Sudo::Command with {
        my $ex = shift @_;
        $success = 0;
        my @error = @{  $ex->error() };
        chomp $error[-1];
        $errorMsg = "@error";
        $errorMsg = _mangleDuplicityErrorMsg($errorMsg);
    } otherwise {
        my ($ex) = @_;
        $success = 0;
        $errorMsg = "$ex";
    };

    if ($success) {
        EBox::info('Backup process finished successfuly');
    } else {
        my $msg = "Backup failed: $errorMsg";
        print "$msg\n";
        EBox::error($msg);
        _cleanup($ebackup);
    }

    _sendSuccessEvent($success, $type, $errorMsg);

} finally {
    if (not $usingCloud) {
        $ebackup->remoteGenerateStatusCache();
    }

    # Create file list
    $ebackup->remoteGenerateListFile();

    $ebackup->backupProcessUnlock();
    $ebackup->unlock();
};

# update logs, we do this even with a failed backup bz it oculd change disk
# usage, with leftover files..
$ebackup->gatherReportInfo();
my $cloudProf = EBox::Global->modInstance('cloud-prof');
if ($cloudProf) {
    $cloudProf->ebackupAlerts();
}

exit 0;
